"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const util_1 = require("../util");
const position_1 = require("../util/position");
const string_1 = require("../util/string");
const workspace_1 = __importDefault(require("../workspace"));
const logger = require('../util/logger')('list-basic');
class BasicList {
    constructor(nvim) {
        this.nvim = nvim;
        this.defaultAction = 'open';
        this.actions = [];
        this.previewHeight = 12;
        this.disposables = [];
        let config = workspace_1.default.getConfiguration('list');
        this.hlGroup = config.get('previewHighlightGroup', 'Search');
        this.previewHeight = config.get('maxPreviewHeight', 12);
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('list')) {
                this.hlGroup = config.get('previewHighlightGroup', 'Search');
                this.previewHeight = config.get('maxPreviewHeight', 12);
            }
        });
    }
    addAction(name, fn, options) {
        this.createAction(Object.assign({
            name,
            execute: fn
        }, options || {}));
    }
    addLocationActions() {
        this.createAction({
            name: 'preview',
            execute: async (item, context) => {
                await this.previewLocation(item.location, context);
            }
        });
        for (let name of ['open', 'tabe', 'drop', 'vsplit', 'split']) {
            this.createAction({
                name,
                execute: async (item) => {
                    if (name == 'open') {
                        await this.jumpTo(item.location);
                    }
                    else {
                        await this.jumpTo(item.location, name);
                    }
                }
            });
        }
    }
    async jumpTo(location, command) {
        let { range, uri } = location;
        let position = range.start;
        if (position.line == 0 && position.character == 0 && position_1.comparePosition(position, range.end) == 0) {
            // allow plugin that remember position.
            position = null;
        }
        await workspace_1.default.jumpTo(uri, position, command);
    }
    createAction(action) {
        let { name } = action;
        let idx = this.actions.findIndex(o => o.name == name);
        // allow override
        if (idx !== -1) {
            this.actions.splice(idx, 1);
        }
        this.actions.push(action);
    }
    async previewLocation(location, context) {
        let { nvim } = this;
        let { uri, range } = location;
        let lineCount = Infinity;
        let doc = workspace_1.default.getDocument(location.uri);
        if (doc)
            lineCount = doc.lineCount;
        let height = Math.min(this.previewHeight, lineCount);
        let u = vscode_uri_1.default.parse(uri);
        let filepath = u.scheme == 'file' ? u.fsPath : u.toString();
        let escaped = await nvim.call('fnameescape', filepath);
        let lnum = range.start.line + 1;
        let mod = context.options.position == 'top' ? 'below' : 'above';
        let winid = context.listWindow.id;
        await nvim.command('pclose');
        let exists = await nvim.call('bufloaded', filepath);
        nvim.pauseNotification();
        nvim.command(`${mod} ${height}sp +setl\\ previewwindow ${escaped}`, true);
        nvim.command(`exe ${lnum}`, true);
        nvim.command('setl winfixheight', true);
        if (range.start.line == range.end.line && range.start.character != range.end.character) {
            let line = await workspace_1.default.getLine(uri, range.start.line);
            let { hlGroup } = this;
            let start = string_1.byteIndex(line, range.start.character) + 1;
            let end = string_1.byteIndex(line, range.end.character) + 1;
            nvim.call('matchaddpos', [hlGroup, [[lnum, start, end - start]]], true);
        }
        if (!exists)
            nvim.command('setl nobuflisted bufhidden=wipe', true);
        nvim.command('normal! zz', true);
        nvim.call('win_gotoid', [winid], true);
        nvim.command('redraw', true);
        await nvim.resumeNotification();
    }
    doHighlight() {
        // noop
    }
    dispose() {
        util_1.disposeAll(this.disposables);
    }
}
exports.default = BasicList;
//# sourceMappingURL=basic.js.map