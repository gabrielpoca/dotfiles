"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const languages_1 = __importDefault(require("../../languages"));
const workspace_1 = __importDefault(require("../../workspace"));
const location_1 = __importDefault(require("./location"));
const convert_1 = require("../../util/convert");
const logger = require('../../util/logger')('list-symbols');
class Symbols extends location_1.default {
    constructor() {
        super(...arguments);
        this.interactive = true;
        this.description = 'search workspace symbols';
        this.detail = 'Symbols list if provided by server, it works on interactive mode only.\n';
        this.name = 'symbols';
    }
    async loadItems(context) {
        let buf = await context.window.buffer;
        let document = workspace_1.default.getDocument(buf.id);
        if (!document)
            return null;
        let { input } = context;
        if (!context.options.interactive) {
            throw new Error('Symbols only works on interactive mode');
        }
        let symbols = await languages_1.default.getWorkspaceSymbols(document.textDocument, input);
        if (!symbols) {
            throw new Error('Workspace symbols provider not found for current document');
        }
        let items = [];
        for (let s of symbols) {
            if (!this.validWorkspaceSymbol(s))
                continue;
            let kind = convert_1.getSymbolKind(s.kind);
            let file = vscode_uri_1.default.parse(s.location.uri).fsPath;
            if (file.startsWith(workspace_1.default.cwd)) {
                file = path_1.default.relative(workspace_1.default.cwd, file);
            }
            items.push({
                label: `${s.name} [${kind}]\t${file}`,
                filterText: `${s.name}`,
                location: s.location
            });
        }
        return items;
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocSymbolsName /\\v^\\s*\\S+/ contained containedin=CocSymbolsLine', true);
        nvim.command('syntax match CocSymbolsKind /\\[\\w\\+\\]\\t/ contained containedin=CocSymbolsLine', true);
        nvim.command('syntax match CocSymbolsFile /\\S\\+$/ contained containedin=CocSymbolsLine', true);
        nvim.command('highlight default link CocSymbolsName Normal', true);
        nvim.command('highlight default link CocSymbolsKind Typedef', true);
        nvim.command('highlight default link CocSymbolsFile Comment', true);
        nvim.resumeNotification();
    }
    validWorkspaceSymbol(symbol) {
        switch (symbol.kind) {
            case vscode_languageserver_types_1.SymbolKind.Namespace:
            case vscode_languageserver_types_1.SymbolKind.Class:
            case vscode_languageserver_types_1.SymbolKind.Module:
            case vscode_languageserver_types_1.SymbolKind.Method:
            case vscode_languageserver_types_1.SymbolKind.Package:
            case vscode_languageserver_types_1.SymbolKind.Interface:
            case vscode_languageserver_types_1.SymbolKind.Function:
            case vscode_languageserver_types_1.SymbolKind.Constant:
                return true;
            default:
                return false;
        }
    }
}
exports.default = Symbols;
//# sourceMappingURL=symbols.js.map