"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const workspace_1 = __importDefault(require("../workspace"));
const logger = require('../util/logger')("outpubChannel");
class BufferChannel {
    constructor(name, nvim) {
        this.name = name;
        this.nvim = nvim;
        this.content = '';
        this.disposables = [];
        this._showing = false;
        this.promise = Promise.resolve(void 0);
        this.bufnr = null;
    }
    get buffer() {
        if (!this.bufnr)
            return null;
        let doc = workspace_1.default.getDocument(this.bufnr);
        return doc ? doc.buffer : null;
    }
    async _append(value, isLine) {
        let { buffer } = this;
        if (!buffer)
            return;
        if (isLine) {
            await buffer.append(value.split('\n'));
        }
        else {
            let last = await this.nvim.call('getbufline', [buffer.id, '$']);
            let content = last + value;
            if (this.buffer) {
                await buffer.setLines(content.split('\n'), {
                    start: -2,
                    end: -1,
                    strictIndexing: false
                });
            }
        }
    }
    append(value) {
        this.content += value;
        this.promise = this.promise.then(() => {
            return this._append(value, false);
        });
    }
    appendLine(value) {
        this.content += value + '\n';
        this.promise = this.promise.then(() => {
            return this._append(value, true);
        });
    }
    clear() {
        this.content = '';
        let { buffer } = this;
        if (buffer) {
            buffer.setLines([], {
                start: 0,
                end: -1,
                strictIndexing: false
            });
        }
    }
    hide() {
        let { nvim } = this;
        let { buffer } = this;
        if (buffer)
            nvim.command(`silent! bd! ${buffer.id}`, true);
    }
    dispose() {
        this.hide();
        this.content = '';
        util_1.disposeAll(this.disposables);
    }
    async openBuffer(preserveFocus) {
        let { nvim } = this;
        if (!this.buffer) {
            await nvim.command(`belowright vs +setl\\ buftype=nofile\\ bufhidden=wipe [coc ${this.name}]`);
            await nvim.command('setfiletype log');
            let buffer = await nvim.buffer;
            await buffer.setOption('swapfile', false);
            await buffer.setLines(this.content.split('\n'), {
                start: 0,
                end: -1,
                strictIndexing: false
            });
            this.bufnr = buffer.id;
        }
        else {
            let wnr = await nvim.call('bufwinnr', this.bufnr);
            // is shown
            if (wnr != -1)
                return;
            await nvim.command(`vert belowright sb ${this.bufnr}`);
        }
        if (preserveFocus) {
            await nvim.command('wincmd p');
        }
    }
    show(preserveFocus) {
        if (this._showing)
            return;
        this._showing = true;
        this.openBuffer(preserveFocus).then(() => {
            this._showing = false;
        }, () => {
            this._showing = false;
        });
    }
}
exports.default = BufferChannel;
//# sourceMappingURL=outputChannel.js.map