"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const codelens_1 = __importDefault(require("./codelens"));
const colors_1 = __importDefault(require("./colors"));
const commands_1 = __importDefault(require("../commands"));
const manager_1 = __importDefault(require("../diagnostic/manager"));
const manager_2 = __importDefault(require("../snippets/manager"));
const events_1 = __importDefault(require("../events"));
const extensions_1 = __importDefault(require("../extensions"));
const languages_1 = __importDefault(require("../languages"));
const services_1 = __importDefault(require("../services"));
const util_1 = require("../util");
const string_1 = require("../util/string");
const workspace_1 = __importDefault(require("../workspace"));
const floatFactory_1 = __importDefault(require("../model/floatFactory"));
const convert_1 = require("../util/convert");
const position_1 = require("../util/position");
const logger = require('../util/logger')('Handler');
class Handler {
    constructor(nvim) {
        this.nvim = nvim;
        /*bufnr and srcId list*/
        this.highlightsMap = new Map();
        this.highlightNamespace = 1080;
        this.documentLines = [];
        this.disposables = [];
        this.getPreferences();
        workspace_1.default.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('coc.preferences')) {
                this.getPreferences();
            }
        });
        workspace_1.default.createNameSpace('coc-highlight').then(id => {
            if (id)
                this.highlightNamespace = id;
        });
        workspace_1.default.createNameSpace('coc-float').then(id => {
            this.hoverFactory = new floatFactory_1.default(nvim, workspace_1.default.env, id);
            let { signaturePreferAbove, signatureMaxHeight } = this.preferences;
            this.signatureFactory = new floatFactory_1.default(nvim, workspace_1.default.env, id, signaturePreferAbove, signatureMaxHeight);
        });
        events_1.default.on(['TextChangedI', 'TextChangedP'], async () => {
            if (this.preferences.signatureHideOnChange) {
                this.signatureFactory.close();
            }
            this.hoverFactory.close();
        }, null, this.disposables);
        let lastInsert;
        events_1.default.on('InsertCharPre', async () => {
            lastInsert = Date.now();
        }, null, this.disposables);
        events_1.default.on('Enter', async (bufnr) => {
            await this.onCharacterType('\n', bufnr);
        }, null, this.disposables);
        events_1.default.on('TextChangedI', async (bufnr) => {
            let curr = Date.now();
            if (!lastInsert || curr - lastInsert > 50)
                return;
            let doc = workspace_1.default.getDocument(bufnr);
            if (!doc)
                return;
            let { triggerSignatureHelp, formatOnType } = this.preferences;
            if (!triggerSignatureHelp && !formatOnType)
                return;
            let pre = await this.getPreviousCharacter();
            if (!pre || string_1.isWord(pre) || doc.paused)
                return;
            await this.onCharacterType(pre, bufnr);
            if (languages_1.default.shouldTriggerSignatureHelp(doc.textDocument, pre)) {
                if (workspace_1.default.isVim)
                    await util_1.wait(50);
                if (doc.dirty) {
                    doc.forceSync();
                    await util_1.wait(60);
                }
                if (lastInsert > curr)
                    return;
                try {
                    await this.showSignatureHelp();
                }
                catch (e) {
                    logger.error(`Error on signature help:`, e);
                }
            }
        }, null, this.disposables);
        events_1.default.on('InsertLeave', async (bufnr) => {
            await this.onCharacterType('\n', bufnr, true);
        }, null, this.disposables);
        events_1.default.on('BufUnload', async (bufnr) => {
            this.clearHighlight(bufnr);
        }, null, this.disposables);
        events_1.default.on('InsertEnter', async () => {
            this.clearHighlight(workspace_1.default.bufnr);
        }, null, this.disposables);
        events_1.default.on('CursorMoved', async (bufnr) => {
            if (!this.preferences.previewAutoClose)
                return;
            this.cursorMoveTs = Date.now();
            if (this.preferences.hoverTarget == 'float')
                return;
            let doc = workspace_1.default.documents.find(doc => doc.uri.startsWith('coc://'));
            if (doc && doc.bufnr != bufnr) {
                nvim.command('pclose', true);
            }
        }, null, this.disposables);
        let provider = {
            onDidChange: null,
            provideTextDocumentContent: async () => {
                nvim.pauseNotification();
                nvim.command('setlocal conceallevel=2 nospell nofoldenable wrap', true);
                nvim.command('setlocal bufhidden=wipe nobuflisted', true);
                nvim.command('setfiletype markdown', true);
                nvim.command(`exe "normal! z${this.documentLines.length}\\<cr>"`, true);
                await nvim.resumeNotification();
                return this.documentLines.join('\n');
            }
        };
        this.disposables.push(workspace_1.default.registerTextDocumentContentProvider('coc', provider));
        this.codeLensManager = new codelens_1.default(nvim);
        this.colors = new colors_1.default(nvim);
    }
    async onHover() {
        let now = Date.now();
        if (this.hoverFactory.creating)
            return;
        let { document, position } = await workspace_1.default.getCurrentState();
        let hovers = await languages_1.default.getHover(document, position);
        if (this.cursorMoveTs && this.cursorMoveTs > now)
            return;
        if (hovers && hovers.length) {
            await this.previewHover(hovers);
        }
        else {
            let target = this.preferences.hoverTarget;
            if (target == 'float') {
                this.hoverFactory.close();
            }
            else if (target == 'preview') {
                this.nvim.command('pclose');
            }
        }
    }
    async gotoDefinition(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let definition = await languages_1.default.getDefinition(document, position);
        if (definition && definition.length != 0) {
            await this.handleLocations(definition, openCommand);
        }
        else {
            workspace_1.default.showMessage('Definition not found', 'warning');
        }
    }
    async gotoDeclaration(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let definition = await languages_1.default.getDeclaration(document, position);
        if (!definition)
            return workspace_1.default.showMessage('Declaration not found', 'warning');
        await this.handleLocations(definition, openCommand);
    }
    async gotoTypeDefinition(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let definition = await languages_1.default.getTypeDefinition(document, position);
        if (definition && definition.length != 0) {
            await this.handleLocations(definition, openCommand);
        }
        else {
            workspace_1.default.showMessage('Type definition not found', 'warning');
        }
    }
    async gotoImplementation(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let definition = await languages_1.default.getImplementation(document, position);
        if (definition && definition.length != 0) {
            await this.handleLocations(definition, openCommand);
        }
        else {
            workspace_1.default.showMessage('Implementation not found', 'warning');
        }
    }
    async gotoReferences(openCommand) {
        let { document, position } = await workspace_1.default.getCurrentState();
        let locs = await languages_1.default.getReferences(document, { includeDeclaration: false }, position);
        if (locs && locs.length) {
            await this.handleLocations(locs, openCommand);
        }
        else {
            workspace_1.default.showMessage('References not found', 'warning');
        }
    }
    async getDocumentSymbols() {
        let document = await workspace_1.default.document;
        if (!document)
            return [];
        let symbols = await languages_1.default.getDocumentSymbol(document.textDocument);
        if (!symbols)
            return null;
        if (symbols.length == 0)
            return [];
        let isSymbols = !symbols[0].hasOwnProperty('location');
        let level = 0;
        let res = [];
        let pre = null;
        if (isSymbols) {
            symbols.sort(sortSymbols);
            for (let sym of symbols) {
                addDoucmentSymbol(res, sym, level);
            }
        }
        else {
            symbols.sort((a, b) => {
                let sa = a.location.range.start;
                let sb = b.location.range.start;
                let d = sa.line - sb.line;
                return d == 0 ? sa.character - sb.character : d;
            });
            for (let sym of symbols) {
                let { name, kind, location, containerName } = sym;
                if (!containerName || !pre) {
                    level = 0;
                }
                else {
                    if (pre.containerName == containerName) {
                        level = pre.level || 0;
                    }
                    else {
                        let container = getPreviousContainer(containerName, res);
                        level = container ? container.level + 1 : 0;
                    }
                }
                let { start } = location.range;
                let o = {
                    col: start.character + 1,
                    lnum: start.line + 1,
                    text: name,
                    level,
                    kind: convert_1.getSymbolKind(kind),
                    selectionRange: location.range,
                    containerName
                };
                res.push(o);
                pre = o;
            }
        }
        return res;
    }
    async getWorkspaceSymbols() {
        let document = await workspace_1.default.document;
        if (!document)
            return;
        let cword = await this.nvim.call('expand', '<cword>');
        let query = await this.nvim.call('input', ['Query:', cword]);
        let symbols = await languages_1.default.getWorkspaceSymbols(document.textDocument, query);
        if (!symbols) {
            workspace_1.default.showMessage('service does not support workspace symbols', 'error');
            return [];
        }
        this.currentSymbols = symbols;
        let res = [];
        for (let s of symbols) {
            if (!this.validWorkspaceSymbol(s))
                continue;
            let { name, kind, location } = s;
            let { start } = location.range;
            res.push({
                filepath: vscode_uri_1.default.parse(location.uri).fsPath,
                col: start.character + 1,
                lnum: start.line + 1,
                text: name,
                kind: convert_1.getSymbolKind(kind),
                selectionRange: location.range
            });
        }
        return res;
    }
    async resolveWorkspaceSymbol(symbolIndex) {
        if (!this.currentSymbols)
            return null;
        let symbol = this.currentSymbols[symbolIndex];
        if (!symbol)
            return null;
        return await languages_1.default.resolveWorkspaceSymbol(symbol);
    }
    async rename() {
        let { nvim } = this;
        let { document, position } = await workspace_1.default.getCurrentState();
        if (!document)
            return;
        let res = await languages_1.default.prepareRename(document, position);
        if (res === false) {
            workspace_1.default.showMessage('Invalid position for rename', 'error');
            return;
        }
        let doc = workspace_1.default.getDocument(document.uri);
        if (!doc)
            return;
        doc.forceSync();
        let curname;
        if (res == null) {
            let range = doc.getWordRangeAtPosition(position);
            if (range)
                curname = document.getText(range);
        }
        else {
            if (vscode_languageserver_protocol_1.Range.is(res)) {
                let line = doc.getline(res.start.line);
                curname = line.slice(res.start.character, res.end.character);
            }
            else {
                curname = res.placeholder;
            }
        }
        if (!curname) {
            workspace_1.default.showMessage('Invalid position', 'warning');
            return;
        }
        let newName = await nvim.call('input', ['new name:', curname]);
        nvim.command('normal! :<C-u>', true);
        if (!newName) {
            workspace_1.default.showMessage('Empty word, canceled', 'warning');
            return;
        }
        let edit = await languages_1.default.provideRenameEdits(document, position, newName);
        if (!edit) {
            workspace_1.default.showMessage('Server return empty response for rename', 'warning');
            return;
        }
        await workspace_1.default.applyEdit(edit);
    }
    async documentFormatting() {
        let document = await workspace_1.default.document;
        if (!document)
            return;
        let options = await workspace_1.default.getFormatOptions();
        let textEdits = await languages_1.default.provideDocumentFormattingEdits(document.textDocument, options);
        if (!textEdits || textEdits.length == 0)
            return;
        await document.applyEdits(this.nvim, textEdits);
    }
    async documentRangeFormatting(mode) {
        let document = await workspace_1.default.document;
        if (!document)
            return -1;
        let range;
        if (mode) {
            range = await this.getSelectedRange(mode, document.textDocument);
            if (!range)
                return -1;
        }
        else {
            let lnum = await this.nvim.getVvar('lnum');
            let count = await this.nvim.getVvar('count');
            let mode = await this.nvim.call('mode');
            // we can't handle
            if (count == 0 || mode == 'i' || mode == 'R')
                return -1;
            range = vscode_languageserver_protocol_1.Range.create(lnum - 1, 0, lnum - 1 + count, 0);
        }
        let options = await workspace_1.default.getFormatOptions();
        let textEdits = await languages_1.default.provideDocumentRangeFormattingEdits(document.textDocument, range, options);
        if (!textEdits)
            return -1;
        await document.applyEdits(this.nvim, textEdits);
        return 0;
    }
    async runCommand(id, ...args) {
        if (id) {
            await events_1.default.fire('Command', [id]);
            commands_1.default.executeCommand(id, ...args);
        }
        else {
            this.nvim.command(`CocList commands`, true);
        }
    }
    async doCodeAction(mode, only) {
        let document = await workspace_1.default.document;
        if (!document)
            return;
        let range;
        if (mode) {
            range = await this.getSelectedRange(mode, document.textDocument);
        }
        else {
            let lnum = await this.nvim.call('line', ['.']);
            range = {
                start: { line: lnum - 1, character: 0 },
                end: { line: lnum, character: 0 }
            };
        }
        let diagnostics = manager_1.default.getDiagnosticsInRange(document.textDocument, range);
        let context = { diagnostics };
        if (only)
            context.only = only;
        let codeActionsMap = await languages_1.default.getCodeActions(document.textDocument, range, context);
        if (!codeActionsMap)
            return workspace_1.default.showMessage('No action available', 'warning');
        let codeActions = [];
        for (let clientId of codeActionsMap.keys()) {
            let actions = codeActionsMap.get(clientId);
            for (let action of actions) {
                action.clientId = clientId;
                codeActions.push(action);
            }
        }
        let idx = await workspace_1.default.showQuickpick(codeActions.map(o => o.title));
        if (idx == -1)
            return;
        let action = codeActions[idx];
        if (action)
            await this.applyCodeAction(action);
    }
    /**
     * Get all quickfix actions of current buffer
     *
     * @public
     * @returns {Promise<CodeAction[]>}
     */
    async getQuickfixActions(range) {
        let document = await workspace_1.default.document;
        if (!document)
            return [];
        range = range || vscode_languageserver_protocol_1.Range.create(0, 0, document.lineCount, 0);
        let diagnostics = manager_1.default.getDiagnosticsInRange(document.textDocument, range);
        let context = { diagnostics, only: [vscode_languageserver_protocol_1.CodeActionKind.QuickFix] };
        let codeActionsMap = await languages_1.default.getCodeActions(document.textDocument, range, context, true);
        if (!codeActionsMap)
            return [];
        let codeActions = [];
        for (let clientId of codeActionsMap.keys()) {
            let actions = codeActionsMap.get(clientId);
            for (let action of actions) {
                if (action.kind !== vscode_languageserver_protocol_1.CodeActionKind.QuickFix)
                    continue;
                action.clientId = clientId;
                codeActions.push(action);
            }
        }
        return codeActions;
    }
    async doQuickfix() {
        let lnum = await this.nvim.call('line', ['.']);
        let range = {
            start: { line: lnum - 1, character: 0 },
            end: { line: lnum, character: 0 }
        };
        let actions = await this.getQuickfixActions(range);
        if (!actions || actions.length == 0) {
            return workspace_1.default.showMessage('No action available', 'warning');
        }
        await this.applyCodeAction(actions[0]);
    }
    async applyCodeAction(action) {
        let { command, edit } = action;
        if (edit)
            await workspace_1.default.applyEdit(edit);
        if (command) {
            if (commands_1.default.has(command.command)) {
                commands_1.default.execute(command);
            }
            else {
                let clientId = action.clientId;
                let service = services_1.default.getService(clientId);
                let params = {
                    command: command.command,
                    arguments: command.arguments
                };
                if (service.client) {
                    let { client } = service;
                    client
                        .sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params)
                        .then(undefined, error => {
                        workspace_1.default.showMessage(`Execute '${command.command} error: ${error}'`, 'error');
                    });
                }
            }
        }
    }
    async doCodeLensAction() {
        await this.codeLensManager.doAction();
    }
    async fold(kind) {
        let document = await workspace_1.default.document;
        let win = await this.nvim.window;
        let foldmethod = await win.getOption('foldmethod');
        if (foldmethod != 'manual') {
            workspace_1.default.showMessage('foldmethod option should be manual!', 'error');
            return;
        }
        let ranges = await languages_1.default.provideFoldingRanges(document.textDocument, {});
        if (!ranges || ranges.length == 0) {
            workspace_1.default.showMessage('no range found', 'warning');
            return;
        }
        if (kind) {
            ranges = ranges.filter(o => o.kind == kind);
        }
        if (ranges && ranges.length) {
            await win.setOption('foldenable', true);
            for (let range of ranges.reverse()) {
                let { startLine, endLine } = range;
                let cmd = `${startLine + 1}, ${endLine + 1}fold`;
                this.nvim.command(cmd, true);
            }
        }
    }
    async pickColor() {
        await this.colors.pickColor();
    }
    async pickPresentation() {
        await this.colors.pickPresentation();
    }
    async highlightDocument(document) {
        let position = await workspace_1.default.getCursorPosition();
        let line = document.getline(position.line);
        let ch = line[position.character];
        if (!ch || !document.isWord(ch)) {
            this.clearHighlight(document.bufnr);
            return;
        }
        if (this.colors.hasColorAtPostion(document.bufnr, position))
            return;
        let highlights = await languages_1.default.getDocumentHighLight(document.textDocument, position);
        let newPosition = await workspace_1.default.getCursorPosition();
        if (position.line != newPosition.line || position.character != newPosition.character) {
            return;
        }
        let ids = this.highlightsMap.get(document.bufnr);
        if (workspace_1.default.isVim && workspace_1.default.bufnr != document.bufnr)
            return;
        this.nvim.pauseNotification();
        if (ids && ids.length) {
            this.clearHighlight(document.bufnr);
        }
        if (highlights && highlights.length) {
            let groups = {};
            for (let hl of highlights) {
                let hlGroup = hl.kind == vscode_languageserver_protocol_1.DocumentHighlightKind.Text
                    ? 'CocHighlightText'
                    : hl.kind == vscode_languageserver_protocol_1.DocumentHighlightKind.Read ? 'CocHighlightRead' : 'CocHighlightWrite';
                groups[hlGroup] = groups[hlGroup] || [];
                groups[hlGroup].push(hl.range);
            }
            let ids = [];
            for (let hlGroup of Object.keys(groups)) {
                let ranges = groups[hlGroup];
                let arr = document.highlightRanges(ranges, hlGroup, this.highlightNamespace);
                ids.push(...arr);
                this.highlightsMap.set(document.bufnr, ids);
            }
        }
        this.nvim.resumeNotification();
    }
    async highlight() {
        let document = workspace_1.default.getDocument(workspace_1.default.bufnr);
        if (!document)
            return;
        await this.highlightDocument(document);
    }
    async links() {
        let doc = await workspace_1.default.document;
        let links = await languages_1.default.getDocumentLinks(doc.textDocument);
        links = links || [];
        let res = [];
        for (let link of links) {
            if (link.target) {
                res.push(link);
            }
            else {
                link = await languages_1.default.resolveDocumentLink(link);
                res.push(link);
            }
        }
        return links;
    }
    async openLink() {
        let { document, position } = await workspace_1.default.getCurrentState();
        let links = await languages_1.default.getDocumentLinks(document);
        if (!links || links.length == 0)
            return false;
        for (let link of links) {
            if (position_1.positionInRange(position, link.range)) {
                let { target } = link;
                if (!target) {
                    link = await languages_1.default.resolveDocumentLink(link);
                    target = link.target;
                }
                if (target) {
                    await workspace_1.default.openResource(target);
                    return true;
                }
                return false;
            }
        }
    }
    validWorkspaceSymbol(symbol) {
        switch (symbol.kind) {
            case vscode_languageserver_protocol_1.SymbolKind.Namespace:
            case vscode_languageserver_protocol_1.SymbolKind.Class:
            case vscode_languageserver_protocol_1.SymbolKind.Module:
            case vscode_languageserver_protocol_1.SymbolKind.Method:
            case vscode_languageserver_protocol_1.SymbolKind.Package:
            case vscode_languageserver_protocol_1.SymbolKind.Interface:
            case vscode_languageserver_protocol_1.SymbolKind.Function:
            case vscode_languageserver_protocol_1.SymbolKind.Constant:
                return true;
            default:
                return false;
        }
    }
    async getCommands() {
        let list = commands_1.default.commandList;
        let res = [];
        let document = await workspace_1.default.document;
        if (!document)
            return [];
        let { commands } = extensions_1.default;
        for (let key of Object.keys(commands)) {
            res.push({
                id: key,
                title: commands[key] || ''
            });
        }
        for (let o of list) {
            if (commands[o.id] == null) {
                res.push({ id: o.id, title: '' });
            }
        }
        return res;
    }
    async onCharacterType(ch, bufnr, insertLeave = false) {
        if (!ch || string_1.isWord(ch) || !this.preferences.formatOnType)
            return;
        if (manager_2.default.getSession(bufnr) != null)
            return;
        let doc = workspace_1.default.getDocument(bufnr);
        if (!doc || doc.paused)
            return;
        if (!languages_1.default.hasOnTypeProvider(ch, doc.textDocument))
            return;
        let position = await workspace_1.default.getCursorPosition();
        let origLine = doc.getline(position.line);
        let { changedtick, dirty } = doc;
        if (dirty) {
            doc.forceSync();
            await util_1.wait(50);
        }
        let pos = insertLeave ? { line: position.line + 1, character: 0 } : position;
        try {
            let edits = await languages_1.default.provideDocumentOntTypeEdits(ch, doc.textDocument, pos);
            // changed by other process
            if (doc.changedtick != changedtick)
                return;
            if (insertLeave) {
                edits = edits.filter(edit => {
                    return edit.range.start.line < position.line + 1;
                });
            }
            if (edits && edits.length) {
                await doc.applyEdits(this.nvim, edits);
                let newLine = doc.getline(position.line);
                if (newLine.length > origLine.length) {
                    let character = position.character + (newLine.length - origLine.length);
                    await workspace_1.default.moveTo(vscode_languageserver_protocol_1.Position.create(position.line, character));
                }
            }
        }
        catch (e) {
            if (!/timeout\s/.test(e.message)) {
                console.error(`Error on formatOnType: ${e.message}`); // tslint:disable-line
            }
        }
    }
    async showSignatureHelp() {
        if (this.signatureTokenSource) {
            this.signatureTokenSource.cancel();
            this.signatureTokenSource.dispose();
            this.signatureTokenSource = null;
        }
        let document = workspace_1.default.getDocument(workspace_1.default.bufnr);
        if (!document)
            return;
        let position = await workspace_1.default.getCursorPosition();
        let part = document.getline(position.line).slice(0, position.character);
        if (/\)\s*$/.test(part))
            return;
        let idx = Math.max(part.lastIndexOf(','), part.lastIndexOf('('));
        if (idx != -1)
            position.character = idx + 1;
        let tokenSource = this.signatureTokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        let timer = setTimeout(() => {
            if (!token.isCancellationRequested) {
                tokenSource.cancel();
            }
        }, 3000);
        let signatureHelp = await languages_1.default.getSignatureHelp(document.textDocument, position, token);
        clearTimeout(timer);
        if (token.isCancellationRequested || !signatureHelp || signatureHelp.signatures.length == 0) {
            this.signatureFactory.close();
            return;
        }
        let { activeParameter, activeSignature, signatures } = signatureHelp;
        if (activeSignature) {
            // make active first
            let [active] = signatures.splice(activeSignature, 1);
            if (active)
                signatures.unshift(active);
        }
        if (this.preferences.signatureHelpTarget == 'float') {
            let paramDoc = null;
            let docs = signatures.reduce((p, c, idx) => {
                let activeIndexes = null;
                if (idx == 0 && activeParameter != null) {
                    let nameIndex = c.label.indexOf('(');
                    let active = c.parameters[activeParameter];
                    if (active) {
                        let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);
                        paramDoc = active.documentation;
                        if (typeof active.label === 'string') {
                            let startIndex = activeParameter == 0 ? 0 : string_1.indexOf(after, ',', activeParameter);
                            startIndex = startIndex == -1 ? 0 : startIndex;
                            let str = after.slice(startIndex);
                            let ms = str.match(new RegExp('\\b' + active.label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b'));
                            let index = ms ? ms.index : str.indexOf(active.label);
                            if (index != -1) {
                                activeIndexes = [
                                    index + startIndex + nameIndex,
                                    index + startIndex + active.label.length + nameIndex
                                ];
                            }
                        }
                        else {
                            activeIndexes = active.label;
                        }
                    }
                }
                p.push({
                    content: c.label,
                    filetype: document.filetype,
                    active: activeIndexes
                });
                if (paramDoc) {
                    let content = typeof paramDoc === 'string' ? paramDoc : paramDoc.value;
                    if (content.trim().length) {
                        p.push({
                            content,
                            filetype: vscode_languageserver_protocol_1.MarkupContent.is(c.documentation) ? 'markdown' : 'txt'
                        });
                    }
                }
                if (idx == 0 && c.documentation) {
                    let { documentation } = c;
                    let content = typeof documentation === 'string' ? documentation : documentation.value;
                    if (content.trim().length) {
                        p.push({
                            content,
                            filetype: vscode_languageserver_protocol_1.MarkupContent.is(c.documentation) ? 'markdown' : 'txt'
                        });
                    }
                }
                return p;
            }, []);
            await this.signatureFactory.create(docs, true);
            // show float
        }
        else {
            let columns = workspace_1.default.env.columns;
            signatures = signatures.slice(0, workspace_1.default.env.cmdheight);
            let signatureList = [];
            for (let signature of signatures) {
                let parts = [];
                let { label } = signature;
                label = label.replace(/\n/g, ' ');
                if (label.length >= columns - 16) {
                    label = label.slice(0, columns - 16) + '...';
                }
                let nameIndex = label.indexOf('(');
                if (nameIndex == -1) {
                    parts = [{ text: label, type: 'Normal' }];
                }
                else {
                    parts.push({
                        text: label.slice(0, nameIndex),
                        type: 'Label'
                    });
                    let after = label.slice(nameIndex);
                    if (signatureList.length == 0 && activeParameter != null) {
                        let active = signature.parameters[activeParameter];
                        if (active) {
                            let start;
                            let end;
                            if (typeof active.label === 'string') {
                                let startIndex = activeParameter == 0 ? 0 : string_1.indexOf(after, ',', activeParameter);
                                startIndex = startIndex == -1 ? 0 : startIndex;
                                let str = after.slice(startIndex);
                                let ms = str.match(new RegExp('\\b' + active.label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b'));
                                let idx = ms ? ms.index : str.indexOf(active.label);
                                if (idx == -1) {
                                    parts.push({ text: after, type: 'Normal' });
                                    continue;
                                }
                                start = idx + startIndex;
                                end = idx + startIndex + active.label.length;
                            }
                            else {
                                [start, end] = active.label;
                                start = start - nameIndex;
                                end = end - nameIndex;
                            }
                            parts.push({ text: after.slice(0, start), type: 'Normal' });
                            parts.push({ text: after.slice(start, end), type: 'MoreMsg' });
                            parts.push({ text: after.slice(end), type: 'Normal' });
                        }
                    }
                    else {
                        parts.push({
                            text: after,
                            type: 'Normal'
                        });
                    }
                }
                signatureList.push(parts);
            }
            this.nvim.callTimer('coc#util#echo_signatures', [signatureList], true);
        }
    }
    async handleLocations(definition, openCommand) {
        if (!definition)
            return;
        if (Array.isArray(definition)) {
            let len = definition.length;
            if (len == 0)
                return;
            if (len == 1) {
                let location = definition[0];
                if (vscode_languageserver_protocol_1.LocationLink.is(definition[0])) {
                    let link = definition[0];
                    location = vscode_languageserver_protocol_1.Location.create(link.targetUri, link.targetRange);
                }
                let { uri, range } = location;
                await workspace_1.default.jumpTo(uri, range.start, openCommand);
            }
            else {
                await workspace_1.default.showLocations(definition);
            }
        }
        else {
            let { uri, range } = definition;
            await workspace_1.default.jumpTo(uri, range.start, openCommand);
        }
    }
    async getSelectedRange(mode, document) {
        let { nvim } = this;
        if (['v', 'V', 'char', 'line'].indexOf(mode) == -1) {
            workspace_1.default.showMessage(`Mode '${mode}' is not supported`, 'error');
            return;
        }
        let isVisual = ['v', 'V'].indexOf(mode) != -1;
        let c = isVisual ? '<' : '[';
        await nvim.command('normal! `' + c);
        let start = await workspace_1.default.getOffset();
        c = isVisual ? '>' : ']';
        await nvim.command('normal! `' + c);
        let end = await workspace_1.default.getOffset() + 1;
        if (start == null || end == null || start == end) {
            workspace_1.default.showMessage(`Failed to get selected range`, 'error');
            return;
        }
        return {
            start: document.positionAt(start),
            end: document.positionAt(end)
        };
    }
    async previewHover(hovers) {
        let lines = [];
        let target = this.preferences.hoverTarget;
        let i = 0;
        let docs = [];
        for (let hover of hovers) {
            let { contents } = hover;
            if (i > 0)
                lines.push('---');
            if (Array.isArray(contents)) {
                for (let item of contents) {
                    if (typeof item === 'string') {
                        if (item.trim().length) {
                            lines.push(...item.split('\n'));
                            docs.push({ content: item, filetype: 'markdown' });
                        }
                    }
                    else {
                        let content = item.value.trim();
                        if (target == 'preview') {
                            content = '``` ' + item.language + '\n' + content + '\n```';
                        }
                        lines.push(...content.trim().split('\n'));
                        docs.push({ filetype: item.language, content: item.value });
                    }
                }
            }
            else if (typeof contents == 'string') {
                lines.push(...contents.split('\n'));
                docs.push({ content: contents, filetype: 'markdown' });
            }
            else if (vscode_languageserver_protocol_1.MarkedString.is(contents)) { // tslint:disable-line
                let content = contents.value.trim();
                if (target == 'preview') {
                    content = '``` ' + contents.language + '\n' + content + '\n```';
                }
                lines.push(...content.split('\n'));
                docs.push({ filetype: contents.language, content: contents.value });
            }
            else if (vscode_languageserver_protocol_1.MarkupContent.is(contents)) {
                lines.push(...contents.value.split('\n'));
                docs.push({ filetype: contents.kind == 'markdown' ? 'markdown' : 'txt', content: contents.value });
            }
            i++;
        }
        if (target == 'echo') {
            await this.nvim.call('coc#util#echo_hover', lines.join('\n').trim());
        }
        else if (target == 'float') {
            manager_1.default.hideFloat();
            await this.hoverFactory.create(docs);
        }
        else {
            this.documentLines = lines;
            await this.nvim.command(`pedit coc://document`);
        }
    }
    clearHighlight(bufnr) {
        let doc = workspace_1.default.getDocument(bufnr);
        let ids = this.highlightsMap.get(bufnr);
        if (ids && ids.length) {
            this.highlightsMap.delete(bufnr);
            if (doc)
                doc.clearMatchIds(ids);
        }
    }
    getPreferences() {
        let config = workspace_1.default.getConfiguration('coc.preferences');
        let signatureConfig = workspace_1.default.getConfiguration('signature');
        let hoverTarget = config.get('hoverTarget', 'float');
        if (hoverTarget == 'float' && !workspace_1.default.env.floating) {
            hoverTarget = 'preview';
        }
        let signatureHelpTarget = signatureConfig.get('target', 'float');
        if (signatureHelpTarget == 'float' && !workspace_1.default.env.floating) {
            signatureHelpTarget = 'echo';
        }
        this.preferences = {
            hoverTarget,
            signatureHelpTarget,
            signatureMaxHeight: signatureConfig.get('maxWindowHeight', 8),
            triggerSignatureHelp: signatureConfig.get('enable', true),
            signaturePreferAbove: signatureConfig.get('preferShownAbove', true),
            signatureHideOnChange: signatureConfig.get('hideOnTextChange', false),
            formatOnType: config.get('formatOnType', false),
            previewAutoClose: config.get('previewAutoClose', false),
        };
    }
    async getPreviousCharacter() {
        let col = await this.nvim.call('col', '.');
        let line = await this.nvim.call('getline', '.');
        let content = string_1.byteSlice(line, 0, col - 1);
        return col == 1 ? '' : content[content.length - 1];
    }
    dispose() {
        this.colors.dispose();
        util_1.disposeAll(this.disposables);
    }
}
exports.default = Handler;
function getPreviousContainer(containerName, symbols) {
    if (!symbols.length)
        return null;
    let i = symbols.length - 1;
    let last = symbols[i];
    if (last.text == containerName) {
        return last;
    }
    while (i >= 0) {
        let sym = symbols[i];
        if (sym.text == containerName) {
            return sym;
        }
        i--;
    }
    return null;
}
function sortSymbols(a, b) {
    let ra = a.selectionRange;
    let rb = b.selectionRange;
    if (ra.start.line < rb.start.line) {
        return -1;
    }
    if (ra.start.line > rb.start.line) {
        return 1;
    }
    return ra.start.character - rb.start.character;
}
function addDoucmentSymbol(res, sym, level) {
    let { name, selectionRange, kind, children, range } = sym;
    let { start } = selectionRange;
    res.push({
        col: start.character + 1,
        lnum: start.line + 1,
        text: name,
        level,
        kind: convert_1.getSymbolKind(kind),
        range,
        selectionRange
    });
    if (children && children.length) {
        children.sort(sortSymbols);
        for (let sym of children) {
            addDoucmentSymbol(res, sym, level + 1);
        }
    }
}
//# sourceMappingURL=index.js.map