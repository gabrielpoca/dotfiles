"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const events_1 = __importDefault(require("../events"));
const workspace_1 = __importDefault(require("../workspace"));
const manager_1 = __importDefault(require("../snippets/manager"));
const util_1 = require("../util");
const floatBuffer_1 = __importDefault(require("./floatBuffer"));
const uuid = require("uuid/v1");
const object_1 = require("../util/object");
const logger = require('../util/logger')('model-float');
const creatingIds = new Set();
// factory class for floating window
class FloatFactory {
    constructor(nvim, env, srcId, preferTop = false, maxHeight = 999) {
        this.nvim = nvim;
        this.env = env;
        this.srcId = srcId;
        this.preferTop = preferTop;
        this.maxHeight = maxHeight;
        this._onWindowCreate = new vscode_languageserver_protocol_1.Emitter();
        this.disposables = [];
        this.promise = Promise.resolve(undefined);
        this.alignTop = false;
        this._creating = false;
        this.moving = false;
        this.createTs = 0;
        this.cursor = [0, 0];
        this.onWindowCreate = this._onWindowCreate.event;
        if (!env.floating)
            return;
        events_1.default.on('BufEnter', bufnr => {
            if (this.buffer && bufnr == this.buffer.id)
                return;
            if (bufnr == this.targetBufnr)
                return;
            this.close();
        }, null, this.disposables);
        events_1.default.on('InsertLeave', bufnr => {
            if (this.buffer && bufnr == this.buffer.id)
                return;
            if (this.moving)
                return;
            this.close();
        }, null, this.disposables);
        events_1.default.on('MenuPopupChanged', async (ev, cursorline) => {
            if (cursorline < ev.row && !this.alignTop) {
                this.close();
            }
            else if (cursorline > ev.row && this.alignTop) {
                this.close();
            }
        }, null, this.disposables);
        events_1.default.on('CursorMovedI', this.onCursorMoved.bind(this, true), null, this.disposables);
        events_1.default.on('CursorMoved', this.onCursorMoved.bind(this, false), null, this.disposables);
    }
    onCursorMoved(insert, bufnr, cursor) {
        if (this.buffer && bufnr == this.buffer.id)
            return;
        if (this.moving || (bufnr == this.targetBufnr && object_1.equals(cursor, this.cursor)))
            return;
        if (insert) {
            if (!this.window)
                return;
            let ts = Date.now();
            setTimeout(() => {
                if (this.createTs > ts)
                    return;
                this.close();
            }, 2000);
        }
        else {
            this.close();
        }
    }
    async createBuffer() {
        let buf = await this.nvim.createNewBuffer(false, true);
        await buf.setOption('buftype', 'nofile');
        await buf.setOption('bufhidden', 'hide');
        return buf;
    }
    get columns() {
        return this.env.columns;
    }
    get lines() {
        return this.env.lines - this.env.cmdheight - 1;
    }
    async getBoundings(docs) {
        let { nvim, preferTop } = this;
        let { columns, lines } = this;
        let alignTop = false;
        let offsetX = 0;
        let [row, col] = await nvim.call('coc#util#win_position');
        let maxWidth = Math.min(columns - 10, 80);
        let height = this.floatBuffer.getHeight(docs, maxWidth);
        height = Math.min(height, this.maxHeight);
        if (!preferTop) {
            if (lines - row < height && row > height) {
                alignTop = true;
            }
        }
        else {
            if (row >= height || row >= lines - row) {
                alignTop = true;
            }
        }
        if (alignTop)
            docs.reverse();
        await this.floatBuffer.setDocuments(docs, maxWidth);
        let { width, highlightOffset } = this.floatBuffer;
        if (col + width > columns) {
            offsetX = col + width - columns;
        }
        offsetX = Math.max(offsetX, highlightOffset);
        offsetX = Math.min(col, offsetX);
        this.alignTop = alignTop;
        return {
            height: alignTop ? Math.min(row, height) : Math.min(height, (lines - row)),
            width: Math.min(columns, width),
            row: alignTop ? -height : 1,
            col: offsetX == 0 ? 0 : -offsetX,
            relative: 'cursor'
        };
    }
    async create(docs, allowSelection = false) {
        if (!this.env.floating)
            return;
        this.createTs = Date.now();
        let id = uuid();
        creatingIds.add(id);
        this.targetBufnr = workspace_1.default.bufnr;
        this.close();
        let tokenSource = this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        this._creating = true;
        this.promise = this.promise.then(() => {
            if (token.isCancellationRequested)
                return;
            return this._create(docs, allowSelection, token).then(() => {
                creatingIds.delete(id);
                this._creating = false;
            }, e => {
                creatingIds.delete(id);
                logger.error('Error on create float window:', e);
                this._creating = false;
            });
        });
        await this.promise;
    }
    async _create(docs, allowSelection = false, token) {
        if (docs.length == 0)
            return;
        let [, line, col] = await this.nvim.call('getpos', ['.']);
        this.cursor = [line, col];
        let { floatBuffer } = this;
        if (floatBuffer) {
            let valid = await floatBuffer.valid;
            if (!valid)
                floatBuffer = null;
        }
        if (!floatBuffer) {
            let buf = await this.createBuffer();
            this.buffer = buf;
            floatBuffer = this.floatBuffer = new floatBuffer_1.default(buf, this.nvim, this.srcId);
        }
        let config = await this.getBoundings(docs);
        if (!config || token.isCancellationRequested)
            return;
        let mode = await this.nvim.call('mode');
        allowSelection = mode == 's' && allowSelection;
        if (token.isCancellationRequested)
            return;
        if (['i', 'n', 'ic'].indexOf(mode) !== -1 || allowSelection) {
            let { nvim, alignTop } = this;
            if (mode == 's')
                await nvim.call('feedkeys', ['\x1b', 'in']);
            let window = await this.nvim.openFloatWindow(this.buffer, false, config);
            if (token.isCancellationRequested) {
                this.closeWindow(window);
                return;
            }
            this.window = window;
            this._onWindowCreate.fire(window);
            nvim.pauseNotification();
            window.setVar('float', 1, true);
            window.setCursor([1, 1], true);
            window.setOption('list', false, true);
            window.setOption('wrap', false, true);
            window.setOption('previewwindow', true, true);
            window.setOption('number', false, true);
            window.setOption('cursorline', false, true);
            window.setOption('cursorcolumn', false, true);
            window.setOption('signcolumn', 'no', true);
            window.setOption('conceallevel', 2, true);
            window.setOption('relativenumber', false, true);
            window.setOption('winhl', `Normal:CocFloating,NormalNC:CocFloating`, true);
            nvim.command(`noa call win_gotoid(${window.id})`, true);
            floatBuffer.setLines();
            if (alignTop)
                nvim.command('normal! G', true);
            nvim.command('noa wincmd p', true);
            await nvim.resumeNotification();
            this.moving = true;
            if (mode == 's') {
                await manager_1.default.selectCurrentPlaceholder(false);
            }
            await util_1.wait(30);
            this.moving = false;
        }
    }
    /**
     * Close float window
     */
    close() {
        if (!this.env.floating)
            return;
        if (this.tokenSource) {
            this.tokenSource.cancel();
            this.tokenSource = null;
        }
        this.closeWindow(this.window);
    }
    closeWindow(window) {
        if (!window)
            return;
        this.nvim.call('coc#util#close_win', window.id, true);
        this.window = null;
        let count = 0;
        let interval = setInterval(() => {
            count++;
            if (count == 5)
                clearInterval(interval);
            window.valid.then(valid => {
                if (valid) {
                    this.nvim.call('coc#util#close_win', window.id, true);
                }
                else {
                    clearInterval(interval);
                }
            }, _e => {
                clearInterval(interval);
            });
        }, 200);
    }
    dispose() {
        if (this.tokenSource) {
            this.tokenSource.cancel();
        }
        this._onWindowCreate.dispose();
        util_1.disposeAll(this.disposables);
    }
    get creating() {
        return this._creating;
    }
    static get isCreating() {
        return creatingIds.size > 0;
    }
}
exports.default = FloatFactory;
//# sourceMappingURL=floatFactory.js.map