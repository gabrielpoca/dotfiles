"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const workspace_1 = __importDefault(require("../workspace"));
const logger = require('../util/logger')('list-mappings');
class Mappings {
    constructor(manager, nvim, config) {
        this.manager = manager;
        this.nvim = nvim;
        this.config = config;
        this.insertMappings = new Map();
        this.normalMappings = new Map();
        let nextKey = config.get('nextKeymap', '<C-j>');
        let previousKey = config.get('previousKeymap', '<C-k>');
        let { prompt } = manager;
        this.add('insert', ' ', () => {
            return prompt.insertCharacter(' ');
        });
        this.add('insert', '<C-k>', () => {
            return prompt.removeTail();
        });
        this.add('insert', '<C-n>', () => {
            return manager.history.next();
        });
        this.add('insert', '<C-p>', () => {
            return manager.history.previous();
        });
        this.add('insert', ['<C-m>', '<cr>'], () => {
            return manager.doAction();
        });
        this.add('insert', ['<C-i>', '\t'], () => {
            return manager.chooseAction();
        });
        this.add('insert', '<C-o>', () => {
            return manager.toggleMode();
        });
        this.add('insert', '<C-c>', async () => {
            manager.stop();
            manager.prompt.start();
            return;
        });
        this.add('insert', '<esc>', () => {
            return manager.cancel();
        });
        this.add('insert', '<C-l>', () => {
            return manager.worker.loadItems(true);
        });
        this.add('insert', '<left>', () => {
            return prompt.moveLeft();
        });
        this.add('insert', '<right>', () => {
            return prompt.moveRight();
        });
        this.add('insert', ['<end>', '<C-e>'], () => {
            return prompt.moveToEnd();
        });
        this.add('insert', ['<home>', '<C-a>'], () => {
            return prompt.moveToStart();
        });
        this.add('insert', ['<C-h>', '<bs>'], () => {
            return prompt.onBackspace();
        });
        this.add('insert', '<C-w>', () => {
            return prompt.removeWord();
        });
        this.add('insert', '<C-u>', () => {
            return prompt.removeAhead();
        });
        this.add('insert', ['<down>', nextKey], () => {
            return manager.normal('j');
        });
        this.add('insert', ['<up>', previousKey], () => {
            return manager.normal('k');
        });
        this.add('insert', ['<ScrollWheelUp>'], this.doScroll.bind(this, '<ScrollWheelUp>'));
        this.add('insert', ['<ScrollWheelDown>'], this.doScroll.bind(this, '<ScrollWheelDown>'));
        this.add('insert', ['<C-f>'], this.doScroll.bind(this, '<C-f>'));
        this.add('insert', ['<C-b>'], this.doScroll.bind(this, '<C-b>'));
        // not allowed
        this.add('normal', '<C-o>', () => {
            return;
        });
        this.add('normal', 't', () => {
            manager.doAction('tabe');
        });
        this.add('normal', 's', () => {
            manager.doAction('split');
        });
        this.add('normal', 'd', () => {
            manager.doAction('drop');
        });
        this.add('normal', ['<cr>', '<C-m>', '\r'], () => {
            manager.doAction();
        });
        this.add('normal', ' ', () => {
            manager.ui.toggleSelection();
        });
        this.add('normal', 'p', () => {
            manager.togglePreview();
        });
        this.add('normal', ['\t', '<C-i>'], () => {
            manager.chooseAction();
        });
        this.add('normal', '<C-c>', () => {
            manager.stop();
        });
        this.add('normal', '<esc>', () => {
            manager.cancel();
        });
        this.add('normal', '<C-l>', () => {
            manager.worker.loadItems(true);
        });
        this.add('normal', ['i', 'I', 'o', 'O', 'a', 'A'], () => {
            manager.toggleMode();
        });
        this.add('normal', '?', async () => {
            await manager.showHelp();
        });
        this.add('normal', ':', async () => {
            await manager.cancel(false);
            await nvim.eval('feedkeys(":")');
        });
        this.add('normal', ['<ScrollWheelUp>'], this.doScroll.bind(this, '<ScrollWheelUp>'));
        this.add('normal', ['<ScrollWheelDown>'], this.doScroll.bind(this, '<ScrollWheelDown>'));
    }
    async doInsertKeymap(key) {
        let insertMappings = this.manager.getConfig('insertMappings', {});
        let expr = insertMappings[key];
        if (expr) {
            await this.evalExpression(expr, 'insert');
            return true;
        }
        if (this.insertMappings.has(key)) {
            let fn = this.insertMappings.get(key);
            await Promise.resolve(fn());
            return true;
        }
        return false;
    }
    async doNormalKeymap(key) {
        let normalMappings = this.manager.getConfig('normalMappings', {});
        let expr = normalMappings[key];
        if (expr) {
            await this.evalExpression(expr, 'normal');
            return true;
        }
        if (this.normalMappings.has(key)) {
            let fn = this.normalMappings.get(key);
            await Promise.resolve(fn());
            return true;
        }
        return false;
    }
    add(mode, key, fn) {
        let mappings = mode == 'insert' ? this.insertMappings : this.normalMappings;
        if (Array.isArray(key)) {
            for (let k of key) {
                mappings.set(k, fn);
            }
        }
        else {
            mappings.set(key, fn);
        }
    }
    async onError(msg) {
        let { nvim } = this;
        await nvim.call('coc#list#stop_prompt', []);
        workspace_1.default.showMessage(msg, 'error');
        this.manager.prompt.start();
    }
    async evalExpression(expr, _mode) {
        if (typeof expr != 'string' || expr.indexOf(':') == -1) {
            await this.onError(`Invalid expression ${expr}`);
            return;
        }
        let { manager } = this;
        let { prompt } = manager;
        let [key, action] = expr.split(':', 2);
        if (key == 'do') {
            switch (action) {
                case 'help':
                    await manager.showHelp();
                    return;
                case 'refresh':
                    await manager.worker.loadItems();
                    return;
                case 'exit':
                    await manager.cancel(true);
                    return;
                case 'stop':
                    manager.stop();
                    return;
                case 'cancel':
                    await manager.cancel(false);
                    return;
                case 'toggle':
                    await manager.ui.toggleSelection();
                    return;
                case 'previous':
                    await manager.normal('k');
                    return;
                case 'next':
                    await manager.normal('j');
                    return;
                case 'defaultaction':
                    await manager.doAction();
                    return;
                default:
                    await this.onError(`'${action}' not supported`);
            }
        }
        else if (key == 'prompt') {
            switch (action) {
                case 'previous':
                    manager.history.previous();
                    return;
                case 'next':
                    manager.history.next();
                    return;
                case 'start':
                    return prompt.moveToStart();
                case 'end':
                    return prompt.moveToEnd();
                case 'left':
                    return prompt.moveLeft();
                case 'right':
                    return prompt.moveRight();
                case 'deleteforward':
                    return prompt.onBackspace();
                case 'deletebackward':
                    return prompt.removeNext();
                case 'removetail':
                    return prompt.removeTail();
                case 'removeahead':
                    return prompt.removeAhead();
                default:
                    await this.onError(`prompt '${action}' not supported`);
            }
        }
        else if (key == 'command') {
            await manager.command(action);
        }
        else if (key == 'action') {
            await manager.doAction(action);
        }
        else if (key == 'feedkeys') {
            await manager.feedkeys(action);
        }
        else if (key == 'normal') {
            await manager.normal(action, false);
        }
        else if (key == 'normal!') {
            await manager.normal(action, true);
        }
        else if (key == 'call') {
            await manager.call(action);
        }
        else if (key == 'expr') {
            let name = await manager.call(action);
            if (name)
                await manager.doAction(name);
        }
        else {
            await this.onError(`Invalid expression ${expr}`);
        }
    }
    async doScroll(key) {
        await this.manager.feedkeys(key);
    }
}
exports.default = Mappings;
//# sourceMappingURL=mappings.js.map