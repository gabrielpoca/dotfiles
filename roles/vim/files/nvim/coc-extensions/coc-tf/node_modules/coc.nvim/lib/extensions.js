"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const glob_1 = __importDefault(require("glob"));
const isuri_1 = __importDefault(require("isuri"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const events_1 = __importDefault(require("./events"));
const util_1 = __importDefault(require("util"));
const util_2 = require("./util");
const array_1 = require("./util/array");
const factory_1 = require("./util/factory");
const fs_2 = require("./util/fs");
const workspace_1 = __importDefault(require("./workspace"));
const child_process_1 = require("child_process");
const watchman_1 = __importDefault(require("./watchman"));
const debounce_1 = require("debounce");
const createLogger = require('./util/logger');
const logger = createLogger('extensions');
function loadJson(file) {
    try {
        let content = fs_1.default.readFileSync(file, 'utf8');
        return JSON.parse(content);
    }
    catch (e) {
        return null;
    }
}
class Extensions {
    constructor() {
        this.list = [];
        this._onReady = new vscode_languageserver_protocol_1.Emitter();
        this._onDidLoadExtension = new vscode_languageserver_protocol_1.Emitter();
        this._onDidActiveExtension = new vscode_languageserver_protocol_1.Emitter();
        this._onDidUnloadExtension = new vscode_languageserver_protocol_1.Emitter();
        this._ready = false;
        this.onReady = this._onReady.event;
        this.onDidLoadExtension = this._onDidLoadExtension.event;
        this.onDidActiveExtension = this._onDidActiveExtension.event;
        this.onDidUnloadExtension = this._onDidUnloadExtension.event;
    }
    get root() {
        return workspace_1.default.env.extensionRoot;
    }
    async init() {
        this.db = workspace_1.default.createDatabase('db');
        let stats = this.globalExtensionStats();
        if (process.env.COC_NO_PLUGINS)
            return;
        this.installExtensions = debounce_1.debounce(this.installExtensions, 200);
        if (global.hasOwnProperty('__TEST__')) {
            this._onReady.fire();
            return;
        }
        stats = stats.filter(o => o.state != 'disabled');
        await Promise.all(stats.map(stat => {
            let folder = stat.root;
            return this.loadExtension(folder).catch(e => {
                workspace_1.default.showMessage(`Can't load extension from ${folder}: ${e.message}'`, 'error');
            });
        })).then(() => {
            return this.addExtensions();
        }).then(() => {
            this._onReady.fire();
            this._ready = true;
            let config = workspace_1.default.getConfiguration('coc.preferences');
            let interval = this.interval = config.get('extensionUpdateCheck', 'daily');
            if (interval == 'never')
                return;
            this.updateExtensions(stats).catch(e => {
                workspace_1.default.showMessage(`Error on update extensions: ${e.message}`, 'error');
            });
        });
        if (workspace_1.default.isVim) {
            this.updateNodeRpc().catch(e => {
                workspace_1.default.showMessage(`Error on update vim-node-rpc: ${e.message}`, 'error');
            });
        }
    }
    get ready() {
        if (this._ready)
            return Promise.resolve();
        return new Promise(resolve => {
            let disposable = this.onReady(() => {
                disposable.dispose();
                resolve();
            });
        });
    }
    async updateExtensions(stats) {
        let now = new Date();
        let { interval, db } = this;
        let day = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (interval == 'daily' ? 0 : 7));
        let ts = await db.fetch('lastUpdate');
        if (ts && Number(ts) > day.getTime())
            return;
        await db.push('lastUpdate', Date.now());
        let versionInfo = {};
        stats = stats.filter(o => !o.exotic);
        let yarncmd = await workspace_1.default.nvim.call('coc#util#yarn_cmd');
        for (let stat of stats) {
            if (stat.exotic)
                continue;
            let file = path_1.default.join(stat.root, 'package.json');
            try {
                let content = await fs_2.readFile(file, 'utf8');
                let obj = JSON.parse(content);
                versionInfo[stat.id] = obj.version;
            }
            catch (e) {
                logger.error(e.stack);
            }
        }
        let outdated = [];
        await Promise.all(Object.keys(versionInfo).map(id => {
            let curr = versionInfo[id];
            return util_2.runCommand(`${yarncmd} info ${id} --json`).then(content => {
                let lines = content.trim().split('\n');
                let json = JSON.parse(lines[lines.length - 1]);
                let { version, engines } = json.data;
                if (version == curr)
                    return;
                if (engines.hasOwnProperty('coc')) {
                    let required = engines.coc.replace(/^\^/, '>=');
                    if (!semver_1.default.satisfies(workspace_1.default.version, required))
                        return;
                    if (semver_1.default.gt(version, curr)) {
                        outdated.push(id);
                    }
                }
                else {
                    outdated.push(id);
                }
            });
        }));
        if (!outdated.length)
            return;
        let status = workspace_1.default.createStatusBarItem(99, { progress: true });
        logger.info(`Upgrading ${outdated.join(' ')}`);
        status.text = `Upgrading ${outdated.join(' ')}`;
        status.show();
        await util_2.runCommand(`${yarncmd} install`, { cwd: this.root });
        const child = child_process_1.spawn(yarncmd, ['upgrade', ...outdated, '--latest', '--ignore-engines'], {
            cwd: this.root,
            detached: true,
            stdio: 'ignore'
        });
        child.unref();
        child.once('exit', () => {
            status.dispose();
        });
    }
    async updateNodeRpc() {
        let now = new Date();
        let day = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        let key = 'lastCheckVimNodeRpc';
        let ts = await this.db.fetch(key);
        if (ts && Number(ts) > day.getTime())
            return;
        let yarncmd = await workspace_1.default.nvim.call('coc#util#yarn_cmd');
        if (!yarncmd)
            return;
        await this.db.push(key, Date.now());
        let filepath = await workspace_1.default.nvim.call('coc#rpc#vim_rpc_folder');
        if (filepath) {
            let jsonFile = path_1.default.join(filepath, 'package.json');
            let { version } = loadJson(jsonFile);
            let res = await util_2.runCommand(`${yarncmd} info vim-node-rpc version --json`);
            let newVersion = JSON.parse(res).data;
            if (!semver_1.default.gt(newVersion, version))
                return;
        }
        workspace_1.default.showMessage(`Upgrading vim-node-rpc`);
        await util_2.runCommand(`${yarncmd} global add vim-node-rpc`);
        logger.info(`Upgrade vim-node-rpc succeed`);
    }
    async addExtensions() {
        let { nvim } = workspace_1.default;
        let { globalExtensions, localExtensions, watchExtensions } = workspace_1.default.env;
        let list = globalExtensions;
        if (list && list.length) {
            list = array_1.distinct(list);
            list = list.filter(name => !this.has(name));
            if (list.length)
                nvim.command(`CocInstall ${list.join(' ')}`, true);
        }
        if (localExtensions.length) {
            localExtensions = array_1.distinct(localExtensions);
            await Promise.all(localExtensions.map(folder => {
                return this.loadExtension(folder).catch(e => {
                    workspace_1.default.showMessage(`Can't load extension from ${folder}: ${e.message}'`, 'error');
                });
            }));
        }
        // watch for changes
        if (watchExtensions.length) {
            let watchmanPath = workspace_1.default.getWatchmanPath();
            if (!watchmanPath || process.env.NODE_ENV == 'test')
                return;
            for (let name of watchExtensions) {
                let directory = await util_1.default.promisify(fs_1.default.realpath)(path_1.default.join(this.root, 'node_modules', name));
                let client = await watchman_1.default.createClient(watchmanPath, directory);
                client.subscribe('**/*.js', debounce_1.debounce(async () => {
                    await this.reloadExtension(name);
                    workspace_1.default.showMessage(`reloaded ${name}`);
                }, 100));
            }
        }
    }
    async installExtensions() {
        let list = await workspace_1.default.nvim.getVar('coc_global_extensions');
        if (list.length) {
            list = array_1.distinct(list);
            list = list.filter(name => !this.has(name));
            if (list.length)
                workspace_1.default.nvim.command(`CocInstall ${list.join(' ')}`, true);
        }
    }
    get all() {
        return this.list.map(o => o.extension);
    }
    get commands() {
        let res = {};
        for (let item of this.list) {
            let { packageJSON } = item.extension;
            if (packageJSON.contributes) {
                let { commands } = packageJSON.contributes;
                if (commands && commands.length) {
                    for (let cmd of commands) {
                        res[cmd.command] = cmd.title;
                    }
                }
            }
        }
        return res;
    }
    getExtensionState(id) {
        let disabled = this.isDisabled(id);
        if (disabled)
            return 'disabled';
        let item = this.list.find(o => o.id == id);
        if (!item)
            return 'unknown';
        let { extension } = item;
        return extension.isActive ? 'activited' : 'loaded';
    }
    getExtensionStates() {
        let globalStats = this.globalExtensionStats();
        let localStats = this.localExtensionStats();
        return globalStats.concat(localStats);
    }
    async toggleExtension(id) {
        let state = this.getExtensionState(id);
        if (state == null)
            return;
        if (state == 'activited') {
            this.deactivate(id);
        }
        if (state != 'disabled') {
            // unload
            let idx = this.list.findIndex(o => o.id == id);
            this.list.splice(idx, 1);
        }
        let { db } = this;
        let key = `extension.${id}.disabled`;
        await db.push(key, state == 'disabled' ? false : true);
        if (state == 'disabled') {
            let folder = path_1.default.join(this.root, 'node_modules', id);
            this.loadExtension(folder).catch(e => {
                workspace_1.default.showMessage(`Can't load extension ${id}: ${e.message}'`, 'error');
            });
        }
        await util_2.wait(200);
    }
    async reloadExtension(id) {
        let idx = this.list.findIndex(o => o.id == id);
        let directory = idx == -1 ? null : this.list[idx].directory;
        this.deactivate(id);
        if (idx != -1)
            this.list.splice(idx, 1);
        await util_2.wait(200);
        if (directory) {
            await this.loadExtension(directory);
        }
        else {
            this.activate(id);
        }
    }
    async uninstallExtension(ids) {
        for (let id of ids) {
            if (!this.isGlobalExtension(id)) {
                workspace_1.default.showMessage(`Global extension '${id}' not found.`, 'error');
                return;
            }
            this.deactivate(id);
        }
        await util_2.wait(100);
        let yarncmd = await workspace_1.default.nvim.call('coc#util#yarn_cmd');
        if (!yarncmd)
            return;
        try {
            await workspace_1.default.runCommand(`${yarncmd} remove ${ids.join(' ')}`, this.root);
            for (let id of ids) {
                this._onDidUnloadExtension.fire(id);
            }
            workspace_1.default.showMessage(`Extensions ${ids.join(' ')} removed`);
        }
        catch (e) {
            workspace_1.default.showMessage(`Uninstall failed: ${e.message}`, 'error');
        }
    }
    isDisabled(id) {
        let { db } = this;
        try {
            let { extension } = JSON.parse(fs_1.default.readFileSync(db.filepath, 'utf8'));
            if (extension && extension[id])
                return extension[id].disabled === true;
            return false;
        }
        catch (e) {
            return false;
        }
    }
    async onExtensionInstall(id) {
        if (/^\w+:/.test(id))
            id = this.packageNameFromUrl(id);
        if (!id || /^-/.test(id))
            return;
        let item = this.list.find(o => o.id == id);
        if (item)
            item.deactivate();
        let folder = path_1.default.join(this.root, 'node_modules', id);
        let stat = await fs_2.statAsync(folder);
        if (stat && stat.isDirectory()) {
            let jsonFile = path_1.default.join(folder, 'package.json');
            let content = await fs_2.readFile(jsonFile, 'utf8');
            let packageJSON = JSON.parse(content);
            let { engines } = packageJSON;
            if (!engines || (!engines.hasOwnProperty('coc') && !engines.hasOwnProperty('vscode'))) {
                let confirmed = await workspace_1.default.showPrompt(`"${id}" is not a valid extension, remove it?`);
                if (confirmed)
                    workspace_1.default.nvim.command(`CocUninstall ${id}`, true);
                return;
            }
            await this.loadExtension(folder);
        }
    }
    has(id) {
        return this.list.find(o => o.id == id) != null;
    }
    isActivted(id) {
        let item = this.list.find(o => o.id == id);
        if (item && item.extension.isActive) {
            return true;
        }
        return false;
    }
    async loadExtension(folder) {
        let jsonFile = path_1.default.join(folder, 'package.json');
        let stat = await fs_2.statAsync(jsonFile);
        if (!stat || !stat.isFile())
            return;
        let content = await fs_2.readFile(jsonFile, 'utf8');
        let packageJSON = JSON.parse(content);
        if (this.isActivted(packageJSON.name)) {
            workspace_1.default.showMessage(`deactivate ${packageJSON.name}`);
            this.deactivate(packageJSON.name);
            await util_2.wait(200);
        }
        let { engines } = packageJSON;
        if (engines && engines.hasOwnProperty('coc')) {
            let required = engines.coc.replace(/^\^/, '>=');
            if (!semver_1.default.satisfies(workspace_1.default.version, required)) {
                workspace_1.default.showMessage(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim >= ${engines.coc}`, 'warning');
            }
            this.createExtension(folder, Object.freeze(packageJSON));
        }
        else if (engines && engines.hasOwnProperty('vscode')) {
            this.createExtension(folder, Object.freeze(packageJSON));
        }
        else {
            workspace_1.default.showMessage(`engine coc & vscode not found in ${jsonFile}`, 'warning');
        }
    }
    loadJson() {
        let { root } = this;
        let jsonFile = path_1.default.join(root, 'package.json');
        if (!fs_1.default.existsSync(jsonFile))
            return null;
        return loadJson(jsonFile);
    }
    packageNameFromUrl(url) {
        let json = this.loadJson();
        if (!json || !json.dependencies)
            return null;
        for (let key of Object.keys(json.dependencies)) {
            let val = json.dependencies[key];
            if (val == url)
                return key;
        }
        return null;
    }
    setupActiveEvents(id, packageJSON) {
        let { activationEvents } = packageJSON;
        if (!activationEvents || activationEvents.indexOf('*') !== -1 || !Array.isArray(activationEvents)) {
            this.activate(id);
            return;
        }
        let active = () => {
            util_2.disposeAll(disposables);
            this.activate(id);
            active = () => { }; // tslint:disable-line
        };
        let disposables = [];
        for (let eventName of activationEvents) {
            let parts = eventName.split(':');
            let ev = parts[0];
            if (ev == 'onLanguage') {
                if (workspace_1.default.filetypes.has(parts[1])) {
                    active();
                    return;
                }
                workspace_1.default.onDidOpenTextDocument(document => {
                    if (document.languageId == parts[1]) {
                        active();
                    }
                }, null, disposables);
            }
            else if (ev == 'onCommand') {
                events_1.default.on('Command', command => {
                    if (command == parts[1]) {
                        active();
                        // wait for service ready
                        return new Promise(resolve => {
                            setTimeout(resolve, 500);
                        });
                    }
                }, null, disposables);
            }
            else if (ev == 'workspaceContains') {
                let check = () => {
                    glob_1.default(parts[1], { cwd: workspace_1.default.root }, (err, files) => {
                        if (err)
                            return;
                        if (files && files.length) {
                            active();
                        }
                    });
                };
                check();
                workspace_1.default.onDidChangeWorkspaceFolder(check, null, disposables);
            }
            else if (ev == 'onFileSystem') {
                for (let doc of workspace_1.default.documents) {
                    let u = vscode_uri_1.default.parse(doc.uri);
                    if (u.scheme == parts[1]) {
                        return active();
                    }
                }
                workspace_1.default.onDidOpenTextDocument(document => {
                    let u = vscode_uri_1.default.parse(document.uri);
                    if (u.scheme == parts[1]) {
                        active();
                    }
                }, null, disposables);
            }
            else {
                workspace_1.default.showMessage(`Unsupported event ${eventName} of ${id}`, 'error');
            }
        }
    }
    activate(id, silent = true) {
        if (this.isDisabled(id)) {
            if (!silent)
                workspace_1.default.showMessage(`Extension ${id} is disabled!`, 'error');
            return;
        }
        let item = this.list.find(o => o.id == id);
        if (!item) {
            workspace_1.default.showMessage(`Extension ${id} not found!`, 'error');
            return;
        }
        let { extension } = item;
        if (extension.isActive)
            return;
        this.ready.then(() => {
            extension.activate().then(() => {
                if (extension.isActive) {
                    this._onDidActiveExtension.fire(extension);
                }
            }, e => {
                workspace_1.default.showMessage(`Error on activate ${extension.id}: ${e.message}`, 'error');
                logger.error(`Error on activate extension ${extension.id}:`, e);
            });
        });
    }
    deactivate(id) {
        let item = this.list.find(o => o.id == id);
        if (!item)
            return false;
        if (item.extension.isActive && typeof item.deactivate == 'function') {
            item.deactivate();
            return true;
        }
        return false;
    }
    // for json schema
    getConfigurations() {
        let res = {};
        for (let item of this.list) {
            let { extension } = item;
            let { packageJSON } = extension;
            let { contributes } = packageJSON;
            if (!contributes || !contributes.configuration) {
                continue;
            }
            let { properties } = contributes.configuration;
            if (!properties) {
                continue;
            }
            for (let prop of properties) {
                res[prop] = properties[prop];
            }
        }
        return res;
    }
    async call(id, method, args) {
        let item = this.list.find(o => o.id == id);
        if (!item)
            return workspace_1.default.showMessage(`extension ${id} not found`, 'error');
        let { extension } = item;
        if (!extension.isActive) {
            workspace_1.default.showMessage(`extension ${id} not activated`, 'error');
            return;
        }
        let { exports } = extension;
        if (!exports || !exports.hasOwnProperty(method)) {
            workspace_1.default.showMessage(`method ${method} not found on extension ${id}`, 'error');
            return;
        }
        return await Promise.resolve(exports[method].apply(null, args));
    }
    createExtension(root, packageJSON) {
        let id = `${packageJSON.name}`;
        let isActive = false;
        let exports = null;
        let filename = path_1.default.join(root, packageJSON.main || 'index.js');
        let ext = factory_1.createExtension(id, filename);
        if (!ext)
            return;
        let context = {
            subscriptions: [],
            extensionPath: root,
            asAbsolutePath: relativePath => {
                return path_1.default.join(root, relativePath);
            },
            storagePath: path_1.default.join(this.root, `${id}-data`),
            logger: createLogger(id)
        };
        let extension = {
            activate: async () => {
                if (isActive)
                    return;
                isActive = true;
                try {
                    exports = await Promise.resolve(ext.activate(context));
                }
                catch (e) {
                    isActive = false;
                    logger.error(e);
                    workspace_1.default.showMessage(`Error on active extension ${id}: ${e.message}`, 'error');
                }
                return exports;
            }
        };
        Object.defineProperties(extension, {
            id: {
                get: () => id
            },
            packageJSON: {
                get: () => packageJSON
            },
            extensionPath: {
                get: () => root
            },
            isActive: {
                get: () => isActive
            },
            exports: {
                get: () => exports
            }
        });
        this.list.push({
            id,
            extension,
            directory: root,
            deactivate: () => {
                isActive = false;
                if (ext.deactivate) {
                    Promise.resolve(ext.deactivate()).catch(e => {
                        logger.error(`Error on ${id} deactivate: `, e.message);
                    });
                }
                util_2.disposeAll(context.subscriptions);
                context.subscriptions = [];
            }
        });
        let { contributes } = packageJSON;
        if (contributes) {
            let { configuration } = contributes;
            if (configuration && configuration.properties) {
                let { properties } = configuration;
                let props = {};
                for (let key of Object.keys(properties)) {
                    let val = properties[key].default;
                    if (val != null)
                        props[key] = val;
                }
                workspace_1.default.configurations.extendsDefaults(props);
            }
        }
        this._onDidLoadExtension.fire(extension);
        this.setupActiveEvents(id, packageJSON);
        return id;
    }
    getExtensionApi(id) {
        let item = this.list.find(o => o.id == id);
        if (!item)
            return null;
        let { extension } = item;
        return extension.isActive ? extension.exports : null;
    }
    registerExtension(extension, deactivate) {
        let { id, packageJSON } = extension;
        this.list.push({ id, extension, deactivate });
        let { contributes } = packageJSON;
        if (contributes) {
            let { configuration } = contributes;
            if (configuration && configuration.properties) {
                let { properties } = configuration;
                let props = {};
                for (let key of Object.keys(properties)) {
                    let val = properties[key].default;
                    if (val != null)
                        props[key] = val;
                }
                workspace_1.default.configurations.extendsDefaults(props);
            }
        }
        this._onDidLoadExtension.fire(extension);
        this.setupActiveEvents(id, packageJSON);
    }
    globalExtensionStats() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
            return [];
        let res = [];
        for (let key of Object.keys(json.dependencies)) {
            let val = json.dependencies[key];
            let root = path_1.default.join(this.root, 'node_modules', key);
            let version = '';
            let description = '';
            let jsonFile = path_1.default.join(root, 'package.json');
            if (fs_1.default.existsSync(jsonFile)) {
                try {
                    let obj = JSON.parse(fs_1.default.readFileSync(jsonFile, 'utf8'));
                    version = obj.version || '';
                    description = obj.description || '';
                }
                catch (e) {
                    logger.error(e);
                }
            }
            res.push({
                id: key,
                version,
                description,
                exotic: isuri_1.default.isValid(val),
                root,
                state: this.getExtensionState(key)
            });
        }
        return res;
    }
    localExtensionStats() {
        let globals = this.globalExtensions;
        let res = [];
        this.list.forEach(item => {
            if (globals.indexOf(item.id) !== -1)
                return;
            let { extensionPath, packageJSON } = item.extension;
            res.push({
                id: packageJSON.name,
                description: packageJSON.description || '',
                version: packageJSON.version || '',
                root: extensionPath,
                exotic: false,
                state: this.getExtensionState(item.id)
            });
        });
        return res;
    }
    isGlobalExtension(id) {
        return this.globalExtensions.indexOf(id) !== -1;
    }
    get globalExtensions() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
            return [];
        return Object.keys(json.dependencies);
    }
}
exports.Extensions = Extensions;
exports.default = new Extensions();
//# sourceMappingURL=extensions.js.map