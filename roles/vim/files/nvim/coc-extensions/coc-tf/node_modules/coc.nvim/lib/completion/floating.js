"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const floatBuffer_1 = __importDefault(require("../model/floatBuffer"));
const workspace_1 = __importDefault(require("../workspace"));
const logger = require('../util/logger')('floating');
class FloatingWindow {
    constructor(nvim, buffer, config) {
        this.nvim = nvim;
        this.buffer = buffer;
        this.config = config;
        this.floatBuffer = new floatBuffer_1.default(buffer, nvim, config.srcId);
    }
    async show(docs, bounding, token) {
        this.bounding = bounding;
        let { nvim } = this;
        let rect = await this.calculateBounding(docs);
        if (this.window) {
            let valid = await this.window.valid;
            if (!valid)
                this.window = null;
        }
        if (token.isCancellationRequested)
            return;
        if (!this.window) {
            try {
                let config = Object.assign({
                    relative: 'editor',
                    focusable: true
                }, rect);
                let win = this.window = await nvim.openFloatWindow(this.buffer, false, config);
                nvim.pauseNotification();
                win.setVar('popup', 1, true);
                win.setVar('float', 1, true);
                win.setOption('list', false, true);
                win.setOption('number', false, true);
                win.setOption('cursorline', false, true);
                win.setOption('cursorcolumn', false, true);
                win.setOption('signcolumn', 'no', true);
                win.setOption('conceallevel', 2, true);
                win.setOption('relativenumber', false, true);
                win.setOption('winhl', 'Normal:CocFloating,NormalNC:CocFloating', true);
                this.showBuffer();
                await nvim.resumeNotification();
            }
            catch (e) {
                logger.error(`Create preview error:`, e.stack);
            }
        }
        else {
            nvim.pauseNotification();
            let config = Object.assign({
                relative: 'editor'
            }, rect);
            this.window.setConfig(config, true);
            this.showBuffer();
            await nvim.resumeNotification();
        }
        if (token.isCancellationRequested) {
            nvim.call('coc#util#close_win', [this.window.id], true);
        }
    }
    showBuffer() {
        let { window, nvim } = this;
        nvim.command(`noa call win_gotoid(${this.window.id})`, true);
        window.notify('nvim_win_set_cursor', [window, [1, 1]]);
        this.floatBuffer.setLines();
        nvim.command('noa wincmd p', true);
    }
    async calculateBounding(docs) {
        // drawn lines
        let { bounding, config, floatBuffer } = this;
        let { columns, lines } = workspace_1.default.env;
        let { maxPreviewWidth } = config;
        let pumWidth = bounding.width + (bounding.scrollbar ? 1 : 0);
        let showRight = true;
        let delta = columns - bounding.col - pumWidth;
        if (delta < maxPreviewWidth && bounding.col > maxPreviewWidth) {
            // show left
            showRight = false;
        }
        let maxWidth = !showRight || delta > maxPreviewWidth ? maxPreviewWidth : delta;
        await floatBuffer.setDocuments(docs, maxWidth);
        let maxHeight = lines - bounding.row - workspace_1.default.env.cmdheight - 1;
        return {
            col: showRight ? bounding.col + pumWidth : bounding.col - floatBuffer.width,
            row: bounding.row,
            height: Math.min(maxHeight, floatBuffer.height),
            width: floatBuffer.width
        };
    }
}
exports.default = FloatingWindow;
//# sourceMappingURL=floating.js.map