"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const highlight_1 = require("../util/highlight");
const string_1 = require("../util/string");
const array_1 = require("../util/array");
const workspace_1 = __importDefault(require("../workspace"));
const chars_1 = require("./chars");
const logger = require('../util/logger')('model-floatBuffer');
class FloatBuffer {
    constructor(buffer, nvim, srcId) {
        this.buffer = buffer;
        this.nvim = nvim;
        this.srcId = srcId;
        this.lines = [];
        this.chars = new chars_1.Chars('@,48-57,_192-255,<,>,$,#,-,`,*');
        this.positions = [];
        this.enableHighlight = true;
        this.width = 0;
        let config = workspace_1.default.getConfiguration('coc.preferences');
        this.enableHighlight = config.get('enableFloatHighlight', true);
    }
    getHeight(docs, maxWidth) {
        let height = docs.reduce((p, c) => {
            return p + this.getLineCount(c, maxWidth);
        }, 0);
        return height + docs.length - 1;
    }
    get valid() {
        return this.buffer.valid;
    }
    get highlightOffset() {
        if (this.positions.length == 0)
            return 0;
        let vals = this.positions.map(s => s[1] - 1);
        return Math.min(...vals);
    }
    async setDocuments(docs, maxWidth) {
        let fragments = [];
        let idx = 0;
        let currLine = 0;
        let newLines = [];
        let fill = false;
        let positions = this.positions = [];
        for (let doc of docs) {
            let isMarkdown = doc.filetype == 'markdown';
            let lines = [];
            let content = doc.content.replace(/\r?\n/g, '\n');
            let arr = content.replace(/\t/g, '  ').split('\n');
            let inBlock = false;
            if (['Error', 'Info', 'Warning', 'Hint'].indexOf(doc.filetype) !== -1) {
                fill = true;
            }
            // join the lines when necessary
            arr = arr.reduce((list, curr) => {
                if (isMarkdown && curr.startsWith('```')) {
                    inBlock = !inBlock;
                }
                if (list.length && curr) {
                    let pre = list[list.length - 1];
                    if (!inBlock && !isSingleLine(pre) && !isBreakCharacter(curr[0])) {
                        list[list.length - 1] = pre + ' ' + curr;
                        return list;
                    }
                }
                list.push(curr);
                return list;
            }, []);
            let { active } = doc;
            for (let str of arr) {
                let len = string_1.byteLength(str);
                if (len > maxWidth - 2) {
                    // don't split on word
                    let parts = this.softSplit(str, maxWidth - 2);
                    if (active) {
                        let count = 0;
                        let inLine = false;
                        let idx = 1;
                        let total = active[1] - active[0];
                        for (let line of parts) {
                            if (count >= total)
                                break;
                            if (!inLine && active[0] < line.length) {
                                inLine = true;
                                let len = line.length > active[1] ? total : line.length - active[0];
                                count = len;
                                positions.push([currLine + idx, active[0] + 2, len]);
                            }
                            else if (inLine && total > count) {
                                let len = (total - count) > line.length ? line.length : total - count;
                                count = count + len;
                                positions.push([currLine + idx, 2, len]);
                            }
                            else if (!inLine) {
                                active[0] = active[0] - line.length;
                                active[1] = active[1] - line.length;
                            }
                            idx = idx + 1;
                        }
                    }
                    lines.push(...parts);
                }
                else {
                    lines.push(str);
                    if (active)
                        positions.push([currLine + 1, active[0] + 2, active[1] - active[0]]);
                }
            }
            if (!lines[lines.length - 1].trim().length) {
                lines = lines.slice(0, lines.length - 1);
            }
            lines = lines.map(s => s.length ? ' ' + s : '');
            fragments.push({
                start: currLine,
                lines,
                filetype: doc.filetype
            });
            newLines.push(...lines);
            if (idx != docs.length - 1) {
                newLines.push('—');
                currLine = currLine + lines.length + 1;
            }
            idx = idx + 1;
        }
        let width = this.width = Math.max(...newLines.map(s => string_1.byteLength(s))) + 1;
        this.lines = newLines.map(s => {
            if (s == '—')
                return '—'.repeat(width);
            if (fill)
                return s + ' '.repeat(width - string_1.byteLength(s));
            return s;
        });
        fragments = fragments.reduce((p, c) => {
            p.push(c, ...this.getCodeFragments(c));
            return p;
        }, []);
        if (this.enableHighlight) {
            let arr = await Promise.all(fragments.map(f => {
                return highlight_1.getHiglights(f.lines, f.filetype).then(highlights => {
                    return highlights.map(highlight => {
                        return Object.assign({}, highlight, { line: highlight.line + f.start });
                    });
                });
            }));
            this.highlights = arr.reduce((p, c) => p.concat(c), []);
        }
        else {
            this.highlights = [];
        }
    }
    getCodeFragments(fragment) {
        if (fragment.filetype !== 'markdown')
            return [];
        let res = [];
        let filetype;
        let lines = [];
        let start = fragment.start;
        let inBlock = false;
        let count = 0;
        for (let line of fragment.lines) {
            let ms = line.match(/^\s*```\s*(\w+)?/);
            if (ms && ms[1]) {
                inBlock = true;
                filetype = ms[1];
                lines = [];
                start = fragment.start + count + 1;
            }
            else if (ms) {
                inBlock = false;
                if (lines.length && filetype) {
                    res.push({
                        filetype: this.fixFiletype(filetype),
                        start,
                        lines
                    });
                }
            }
            else if (inBlock) {
                lines.push(line);
            }
            count = count + 1;
        }
        return res;
    }
    fixFiletype(filetype) {
        if (filetype == 'ts')
            return 'typescript';
        if (filetype == 'js')
            return 'javascript';
        return filetype;
    }
    get height() {
        return this.lines.length;
    }
    setLines() {
        let { buffer, lines, nvim, highlights, srcId } = this;
        nvim.call('clearmatches', [], true);
        buffer.clearNamespace(-1);
        buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false }, true);
        if (highlights.length) {
            let positions = [];
            for (let highlight of highlights) {
                buffer.addHighlight({
                    srcId,
                    hlGroup: highlight.hlGroup,
                    line: highlight.line,
                    colStart: highlight.colStart,
                    colEnd: highlight.colEnd
                });
                if (highlight.isMarkdown) {
                    let line = lines[highlight.line];
                    let before = line[string_1.characterIndex(line, highlight.colStart)];
                    let after = line[string_1.characterIndex(line, highlight.colEnd) - 1];
                    if (before == after && ['_', '`', '*'].indexOf(before) !== -1) {
                        positions.push([highlight.line + 1, highlight.colStart + 1]);
                        positions.push([highlight.line + 1, highlight.colEnd]);
                    }
                }
            }
            for (let arr of array_1.group(positions, 8)) {
                nvim.call('matchaddpos', ['Conceal', arr], true);
            }
        }
        if (this.positions.length) {
            for (let arr of array_1.group(this.positions, 8)) {
                nvim.call('matchaddpos', ['CocUnderline', arr], true);
            }
        }
    }
    softSplit(line, maxWidth) {
        let { chars } = this;
        let res = [];
        let finished = false;
        let start = 0;
        do {
            let len = 0;
            let lastNonKeyword = 0;
            for (let i = start; i < line.length; i++) {
                let ch = line[i];
                let code = ch.charCodeAt(0);
                let iskeyword = code < 255 && chars.isKeywordCode(code);
                if (len >= maxWidth) {
                    if (iskeyword && lastNonKeyword) {
                        res.push(line.slice(start, lastNonKeyword + 1).replace(/\s+$/, ''));
                        start = lastNonKeyword + 1;
                    }
                    else {
                        let end = len == maxWidth ? i : i - 1;
                        res.push(line.slice(start, end).replace(/\s+$/, ''));
                        start = end;
                    }
                    break;
                }
                len = len + string_1.byteLength(ch);
                if (!iskeyword)
                    lastNonKeyword = i;
                if (i == line.length - 1) {
                    let content = line.slice(start, i + 1).replace(/\s+$/, '');
                    if (content.length)
                        res.push(content);
                    finished = true;
                }
            }
        } while (!finished);
        return res;
    }
    getLineCount(doc, maxWidth) {
        let count = 0;
        let isMarkdown = doc.filetype == 'markdown';
        let content = doc.content.replace(/\r?\n/g, '\n');
        let arr = content.replace(/\t/g, '  ').split('\n');
        let inBlock = false;
        // join the lines when necessary
        arr = arr.reduce((list, curr) => {
            if (isMarkdown && curr.startsWith('```')) {
                inBlock = !inBlock;
            }
            if (list.length && curr) {
                let pre = list[list.length - 1];
                if (!inBlock && !isSingleLine(pre) && !isBreakCharacter(curr[0])) {
                    list[list.length - 1] = pre + ' ' + curr;
                    return list;
                }
            }
            list.push(curr);
            return list;
        }, []);
        for (let str of arr) {
            let len = string_1.byteLength(str);
            if (len > maxWidth - 2) {
                // don't split on word
                let parts = this.softSplit(str, maxWidth - 2);
                count += parts.length;
            }
            else {
                count += 1;
            }
        }
        return count;
    }
}
exports.default = FloatBuffer;
function isSingleLine(line) {
    if (line.trim().length == 0)
        return true;
    if (/^\s*$/.test(line))
        return true;
    if (/^\s*(-|\*)\s/.test(line))
        return true;
    if (line.startsWith('#'))
        return true;
    return false;
}
function isBreakCharacter(ch) {
    let code = ch.charCodeAt(0);
    if (code > 255)
        return false;
    if (code >= 48 && code <= 57)
        return false;
    if (code >= 97 && code <= 122)
        return false;
    if (code >= 65 && code <= 90)
        return false;
    return true;
}
//# sourceMappingURL=floatBuffer.js.map