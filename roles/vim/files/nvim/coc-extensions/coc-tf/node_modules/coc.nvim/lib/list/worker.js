"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const ansiparse_1 = require("../util/ansiparse");
const diff_1 = require("../util/diff");
const fuzzy_1 = require("../util/fuzzy");
const score_1 = require("../util/score");
const string_1 = require("../util/string");
const workspace_1 = __importDefault(require("../workspace"));
const uuidv1 = require("uuid/v1");
const frames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
const logger = require('../util/logger')('list-worker');
const controlCode = '\x1b';
// perform loading task
class Worker {
    constructor(nvim, manager) {
        this.nvim = nvim;
        this.manager = manager;
        this._loading = false;
        this.task = null;
        this.mruList = [];
        this.totalItems = [];
        this._onDidChangeItems = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeItems = this._onDidChangeItems.event;
        let { prompt } = manager;
        prompt.onDidChangeInput(async () => {
            let { listOptions } = manager;
            let { interactive } = listOptions;
            if (this.timer)
                clearTimeout(this.timer);
            if (interactive) {
                this.stop();
                this.timer = setTimeout(async () => {
                    await this.loadItems();
                }, 100);
            }
            else if (!this._loading && this.length) {
                let wait = Math.min(Math.floor(this.length / 200), 200);
                this.timer = setTimeout(async () => {
                    if (this._loading)
                        return;
                    await this.drawItems();
                }, wait);
            }
        });
    }
    set loading(loading) {
        if (this._loading == loading)
            return;
        this._loading = loading;
        let { nvim } = this;
        if (loading) {
            this.interval = setInterval(async () => {
                let idx = Math.floor((new Date()).getMilliseconds() / 100);
                nvim.pauseNotification();
                nvim.setVar('coc_list_loading_status', frames[idx], true);
                nvim.command('redraws', true);
                await nvim.resumeNotification();
            }, 100);
        }
        else {
            if (this.interval) {
                clearInterval(this.interval);
                nvim.pauseNotification();
                nvim.setVar('coc_list_loading_status', '', true);
                nvim.command('redraws', true);
                nvim.resumeNotification();
            }
        }
    }
    async loadItems(reload = false) {
        let { context, list, listOptions } = this.manager;
        if (!list)
            return;
        this.columns = await this.nvim.getOption('columns');
        let id = this.taskId = uuidv1();
        this.loading = true;
        let { interactive } = listOptions;
        await this.loadMruList(context.cwd);
        let items = await list.loadItems(context);
        if (!items || Array.isArray(items)) {
            items = (items || []);
            this.totalItems = items.map(item => {
                item.label = this.fixLabel(item.label);
                this.parseListItemAnsi(item);
                this.recentScore(item);
                return item;
            });
            this.loading = false;
            let highlights = [];
            if (!interactive) {
                let res = this.filterItems(items);
                items = res.items;
                highlights = res.highlights;
            }
            else {
                highlights = this.getItemsHighlight(items);
            }
            this._onDidChangeItems.fire({
                items,
                highlights,
                reload
            });
        }
        else {
            let task = this.task = items;
            let totalItems = this.totalItems = [];
            let count = 0;
            let currInput = context.input;
            let timer;
            let lastTs;
            let _onData = async () => {
                lastTs = Date.now();
                if (this.taskId != id || !this.manager.isActivated)
                    return;
                if (count >= totalItems.length)
                    return;
                let inputChanged = this.input != currInput;
                if (interactive && inputChanged)
                    return;
                if (count == 0 || inputChanged) {
                    currInput = this.input;
                    count = totalItems.length;
                    let items;
                    let highlights = [];
                    if (interactive) {
                        items = totalItems.slice();
                        highlights = this.getItemsHighlight(items);
                    }
                    else {
                        let res = this.filterItems(totalItems);
                        items = res.items;
                        highlights = res.highlights;
                    }
                    this._onDidChangeItems.fire({ items, highlights, reload, append: false });
                }
                else {
                    let remain = totalItems.slice(count);
                    count = totalItems.length;
                    let items;
                    let highlights = [];
                    if (!interactive) {
                        let res = this.filterItems(remain);
                        items = res.items;
                        highlights = res.highlights;
                    }
                    else {
                        items = remain;
                        highlights = this.getItemsHighlight(remain);
                    }
                    this._onDidChangeItems.fire({ items, highlights, append: true });
                }
            };
            task.on('data', async (item) => {
                if (timer)
                    clearTimeout(timer);
                if (this.taskId != id || !this._loading)
                    return;
                if (interactive && this.input != currInput)
                    return;
                item.label = this.fixLabel(item.label);
                this.parseListItemAnsi(item);
                this.recentScore(item);
                totalItems.push(item);
                if ((!lastTs && totalItems.length == 500)
                    || Date.now() - lastTs > 200) {
                    _onData();
                }
                else if (lastTs && this.input != currInput) {
                    _onData();
                }
                else {
                    timer = setTimeout(_onData, 60);
                }
            });
            await new Promise((resolve, reject) => {
                task.on('error', async (msg) => {
                    if (timer)
                        clearTimeout(timer);
                    this.loading = false;
                    reject(new Error(msg));
                });
                task.on('end', async () => {
                    this.loading = false;
                    if (timer)
                        clearTimeout(timer);
                    if (totalItems.length == 0) {
                        this._onDidChangeItems.fire({ items: [], highlights: [] });
                    }
                    else {
                        _onData();
                    }
                    resolve();
                });
            });
        }
    }
    // draw all items with filter if necessary
    async drawItems() {
        let { totalItems } = this;
        let { listOptions, isActivated } = this.manager;
        if (!isActivated)
            return;
        let { interactive } = listOptions;
        let items = totalItems;
        let highlights = [];
        if (!interactive) {
            let res = this.filterItems(totalItems);
            items = res.items;
            highlights = res.highlights;
        }
        else {
            highlights = this.getItemsHighlight(items);
        }
        this._onDidChangeItems.fire({ items, highlights });
    }
    stop() {
        this.loading = false;
        if (this.timer) {
            clearTimeout(this.timer);
        }
        if (this.task) {
            this.task.dispose();
            this.task = null;
            this.taskId = null;
        }
    }
    get length() {
        return this.totalItems.length;
    }
    get input() {
        return this.manager.prompt.input;
    }
    getItemsHighlight(items) {
        let { input } = this;
        if (!input)
            return [];
        return items.map(item => {
            let filterLabel = getFilterLabel(item);
            if (filterLabel == '')
                return null;
            let res = score_1.getMatchResult(filterLabel, input);
            if (!res || !res.score)
                return null;
            return this.getHighlights(filterLabel, res.matches);
        });
    }
    filterItems(items) {
        let { input } = this.manager.prompt;
        let highlights = [];
        let { sort, matcher, ignorecase } = this.manager.listOptions;
        if (input.length == 0) {
            let filtered = items.slice();
            let sort = filtered.length && typeof filtered[0].recentScore == 'number';
            return {
                items: sort ? filtered.sort((a, b) => b.recentScore - a.recentScore) : filtered,
                highlights
            };
        }
        let filtered;
        if (input.length > 0) {
            if (matcher == 'strict') {
                filtered = items.filter(item => {
                    let text = item.filterText || item.label;
                    if (!ignorecase)
                        return text.indexOf(input) !== -1;
                    return text.toLowerCase().indexOf(input.toLowerCase()) !== -1;
                });
                for (let item of filtered) {
                    let filterLabel = getFilterLabel(item);
                    let idx = ignorecase ? filterLabel.toLocaleLowerCase().indexOf(input.toLowerCase()) : filterLabel.indexOf(input);
                    if (idx != -1) {
                        highlights.push({
                            spans: [[string_1.byteIndex(filterLabel, idx), string_1.byteIndex(filterLabel, idx + input.length)]]
                        });
                    }
                }
            }
            else if (matcher == 'regex') {
                let regex = new RegExp(input, ignorecase ? 'i' : '');
                filtered = items.filter(item => regex.test(item.filterText || item.label));
                for (let item of filtered) {
                    let filterLabel = getFilterLabel(item);
                    let ms = filterLabel.match(regex);
                    if (ms && ms.length) {
                        highlights.push({
                            spans: [[string_1.byteIndex(filterLabel, ms.index), string_1.byteIndex(filterLabel, ms.index + ms[0].length)]]
                        });
                    }
                }
            }
            else {
                let codes = fuzzy_1.getCharCodes(input);
                filtered = items.filter(item => fuzzy_1.fuzzyMatch(codes, item.filterText || item.label));
                filtered = filtered.map(item => {
                    let filename = item.location ? path_1.default.basename(item.location.uri) : null;
                    let filterLabel = getFilterLabel(item);
                    let res = score_1.getMatchResult(filterLabel, input, filename);
                    return Object.assign({}, item, {
                        filterLabel,
                        score: res ? res.score : 0,
                        matches: res ? res.matches : []
                    });
                });
                if (sort && items.length) {
                    filtered.sort((a, b) => {
                        if (a.score != b.score)
                            return b.score - a.score;
                        if (a.location && b.location) {
                            if (a.location.uri.length != b.location.uri.length) {
                                return a.location.uri.length - b.location.uri.length;
                            }
                            return a.location.uri > b.location.uri ? 1 : -1;
                        }
                        return a.label > b.label ? 1 : -1;
                    });
                }
                for (let item of filtered) {
                    if (!item.matches)
                        continue;
                    let hi = this.getHighlights(item.filterLabel, item.matches);
                    highlights.push(hi);
                }
            }
        }
        return {
            items: filtered,
            highlights
        };
    }
    getHighlights(text, matches) {
        let spans = [];
        if (matches.length) {
            let start = matches.shift();
            let next = matches.shift();
            let curr = start;
            while (next) {
                if (next == curr + 1) {
                    curr = next;
                    next = matches.shift();
                    continue;
                }
                spans.push([string_1.byteIndex(text, start), string_1.byteIndex(text, curr) + 1]);
                start = next;
                curr = start;
                next = matches.shift();
            }
            spans.push([string_1.byteIndex(text, start), string_1.byteIndex(text, curr) + 1]);
        }
        return { spans };
    }
    async loadMruList(cwd) {
        try {
            let mru = workspace_1.default.createMru('mru');
            let files = await mru.load();
            this.mruList = files.filter(s => s.startsWith(cwd));
        }
        catch (e) {
            this.mruList = [];
            // noop
        }
    }
    // set correct label, add ansi highlights
    parseListItemAnsi(item) {
        let { label } = item;
        if (item.ansiHighlights || label.indexOf(controlCode) == -1)
            return;
        let ansiItems = ansiparse_1.ansiparse(label);
        let newLabel = '';
        let highlights = [];
        for (let item of ansiItems) {
            let old = newLabel;
            newLabel = newLabel + item.text;
            let { foreground, background } = item;
            if (foreground || background) {
                let span = [string_1.byteLength(old), string_1.byteLength(newLabel)];
                let hlGroup = '';
                if (foreground && background) {
                    hlGroup = `CocList${string_1.upperFirst(foreground)}${string_1.upperFirst(background)}`;
                }
                else if (foreground) {
                    hlGroup = `CocListFg${string_1.upperFirst(foreground)}`;
                }
                else if (background) {
                    hlGroup = `CocListBg${string_1.upperFirst(background)}`;
                }
                highlights.push({ span, hlGroup });
            }
        }
        item.label = newLabel;
        item.ansiHighlights = highlights;
    }
    recentScore(item) {
        let { location } = item;
        if (!location || item.recentScore)
            return;
        let list = this.mruList;
        let len = list.length;
        let idx = list.indexOf(vscode_uri_1.default.parse(location.uri).fsPath);
        item.recentScore = idx == -1 ? -1 : len - idx;
    }
    fixLabel(label) {
        let { columns } = this;
        label = label.split('\n').join(' ');
        return label.slice(0, columns * 2);
    }
}
exports.default = Worker;
function getFilterLabel(item) {
    return item.filterText != null ? diff_1.patchLine(item.filterText, item.label) : item.label;
}
//# sourceMappingURL=worker.js.map