"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const net_1 = __importDefault(require("net"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
const readline_1 = __importDefault(require("readline"));
const find_up_1 = __importDefault(require("find-up"));
const logger = require('./logger')('util-fs');
async function statAsync(filepath) {
    let stat = null;
    try {
        stat = await util_1.default.promisify(fs_1.default.stat)(filepath);
    }
    catch (e) { } // tslint:disable-line
    return stat;
}
exports.statAsync = statAsync;
async function isDirectory(filepath) {
    let stat = await statAsync(filepath);
    return stat && stat.isDirectory();
}
exports.isDirectory = isDirectory;
async function unlinkAsync(filepath) {
    try {
        await util_1.default.promisify(fs_1.default.unlink)(filepath);
    }
    catch (e) { } // tslint:disable-line
}
exports.unlinkAsync = unlinkAsync;
function renameAsync(oldPath, newPath) {
    return new Promise((resolve, reject) => {
        fs_1.default.rename(oldPath, newPath, err => {
            if (err)
                return reject(err);
            resolve();
        });
    });
}
exports.renameAsync = renameAsync;
async function isGitIgnored(fullpath) {
    if (!fullpath)
        return false;
    let stat = await statAsync(fullpath);
    if (!stat || !stat.isFile())
        return false;
    let root = null;
    try {
        let { stdout } = await util_1.default.promisify(child_process_1.exec)('git rev-parse --show-toplevel', { cwd: path_1.default.dirname(fullpath) });
        root = stdout.trim();
    }
    catch (e) { } // tslint:disable-line
    if (!root)
        return false;
    let file = path_1.default.relative(root, fullpath);
    try {
        let { stdout } = await util_1.default.promisify(child_process_1.exec)(`git check-ignore ${file}`, { cwd: root });
        return stdout.trim() == file;
    }
    catch (e) { } // tslint:disable-line
    return false;
}
exports.isGitIgnored = isGitIgnored;
function resolveRoot(cwd, subs) {
    let home = os_1.default.homedir();
    let { root } = path_1.default.parse(cwd);
    let p = find_up_1.default.sync(subs, { cwd });
    p = p == null ? null : path_1.default.dirname(p);
    if (p == null || p == home || p == root)
        return cwd;
    return p;
}
exports.resolveRoot = resolveRoot;
function readFile(fullpath, encoding) {
    return new Promise((resolve, reject) => {
        fs_1.default.readFile(fullpath, encoding, (err, content) => {
            if (err)
                reject(err);
            resolve(content);
        });
    });
}
exports.readFile = readFile;
function readFileLine(fullpath, count) {
    const rl = readline_1.default.createInterface({
        input: fs_1.default.createReadStream(fullpath, { encoding: 'utf8' }),
        crlfDelay: Infinity,
        terminal: false
    });
    let n = 0;
    return new Promise((resolve, reject) => {
        rl.on('line', line => {
            if (n == count) {
                rl.close();
                resolve(line);
                return;
            }
            n = n + 1;
        });
        rl.on('error', reject);
    });
}
exports.readFileLine = readFileLine;
async function writeFile(fullpath, content) {
    await util_1.default.promisify(fs_1.default.writeFile)(fullpath, content, 'utf8');
}
exports.writeFile = writeFile;
function validSocket(path) {
    let clientSocket = new net_1.default.Socket();
    return new Promise(resolve => {
        clientSocket.on('error', () => {
            resolve(false);
        });
        clientSocket.connect({ path }, () => {
            clientSocket.unref();
            resolve(true);
        });
    });
}
exports.validSocket = validSocket;
async function readdirAsync(path) {
    return await util_1.default.promisify(fs_1.default.readdir)(path);
}
exports.readdirAsync = readdirAsync;
function isFile(uri) {
    return uri.startsWith('file:');
}
exports.isFile = isFile;
//# sourceMappingURL=fs.js.map