"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const object_1 = require("../util/object");
const position_1 = require("../util/position");
const Snippets = __importStar(require("./parser"));
const logger = require('../util/logger')('snippets-snipet');
class CocSnippet {
    constructor(_snippetString, position, _variableResolver) {
        this._snippetString = _snippetString;
        this.position = position;
        this._variableResolver = _variableResolver;
        this._parser = new Snippets.SnippetParser();
        const snippet = this._parser.parse(this._snippetString, true);
        if (_variableResolver) {
            snippet.resolveVariables(_variableResolver);
        }
        this.tmSnippet = snippet;
        this.update();
    }
    adjustPosition(characterCount, lineCount) {
        let { line, character } = this.position;
        this.position = {
            line: line + lineCount,
            character: character + characterCount
        };
        this.update();
    }
    adjustTextEdit(edit) {
        let { range } = edit;
        if (position_1.comparePosition(this.range.start, range.end) < 0)
            return false;
        let changed = position_1.getChangedPosition(this.range.start, edit);
        if (changed.line == 0 && changed.character == 0)
            return true;
        this.adjustPosition(changed.character, changed.line);
        return true;
    }
    get isPlainText() {
        return this._placeholders.every(p => p.isFinalTabstop);
    }
    toString() {
        return this.tmSnippet.toString();
    }
    get range() {
        let { position } = this;
        const content = this.tmSnippet.toString();
        const doc = vscode_languageserver_protocol_1.TextDocument.create('untitled:/1', 'snippet', 0, content);
        const pos = doc.positionAt(content.length);
        const end = pos.line == 0 ? position.character + pos.character : pos.character;
        return vscode_languageserver_protocol_1.Range.create(position, vscode_languageserver_protocol_1.Position.create(position.line + pos.line, end));
    }
    get firstPlaceholder() {
        return this.getPlaceholder(this.tmSnippet.minIndexNumber);
    }
    get lastPlaceholder() {
        return this.getPlaceholder(this.tmSnippet.maxIndexNumber);
    }
    getPlaceholderById(id) {
        return this._placeholders.find(o => o.id == id);
    }
    getPlaceholder(index) {
        let placeholders = this._placeholders.filter(o => o.index == index);
        let filtered = placeholders.filter(o => !o.transform);
        return filtered.length ? filtered[0] : placeholders[0];
    }
    getPrevPlaceholder(index) {
        if (index == 0)
            return this.lastPlaceholder;
        let prev = this.getPlaceholder(index - 1);
        if (!prev)
            return this.getPrevPlaceholder(index - 1);
        return prev;
    }
    getNextPlaceholder(index) {
        let max = this.tmSnippet.maxIndexNumber;
        if (index == max)
            return this.finalPlaceholder;
        let next = this.getPlaceholder(index + 1);
        if (!next)
            return this.getNextPlaceholder(index + 1);
        return next;
    }
    get finalPlaceholder() {
        return this._placeholders.find(o => o.isFinalTabstop);
    }
    getPlaceholderByRange(range) {
        return this._placeholders.find(o => {
            return position_1.rangeInRange(range, o.range);
        });
    }
    insertSnippet(placeholder, snippet, position) {
        let { start } = placeholder.range;
        let offset = position.character - start.character;
        let insertFinal = true;
        let next = this._placeholders[placeholder.id + 1];
        if (next && object_1.equals(next.range.start, position)) {
            insertFinal = false;
        }
        let first = this.tmSnippet.insertSnippet(snippet, placeholder.id, offset, insertFinal);
        this.update();
        return first;
    }
    // update internal positions, no change of buffer
    // return TextEdit list when needed
    updatePlaceholder(placeholder, edit) {
        let { start, end } = edit.range;
        let { range } = this;
        let { value, id } = placeholder;
        let newText = position_1.editRange(placeholder.range, value, edit);
        this.tmSnippet.updatePlaceholder(id, newText);
        let endPosition = position_1.adjustPosition(range.end, edit);
        let snippetEdit = {
            range: vscode_languageserver_protocol_1.Range.create(range.start, endPosition),
            newText: this.tmSnippet.toString()
        };
        this.update();
        return [snippetEdit];
    }
    update() {
        const snippet = this.tmSnippet;
        const placeholders = snippet.placeholders;
        const { line, character } = this.position;
        const document = vscode_languageserver_protocol_1.TextDocument.create('untitled:/1', 'snippet', 0, snippet.toString());
        this._placeholders = placeholders.map((p, idx) => {
            const offset = snippet.offset(p);
            const position = document.positionAt(offset);
            const start = {
                line: line + position.line,
                character: position.line == 0 ? character + position.character : position.character
            };
            const value = p.toString();
            const lines = value.split('\n');
            let res = {
                range: vscode_languageserver_protocol_1.Range.create(start, {
                    line: start.line + lines.length - 1,
                    character: lines.length == 1 ? start.character + value.length : lines[lines.length - 1].length
                }),
                transform: p.transform != null,
                line: start.line,
                id: idx,
                index: p.index,
                value,
                isFinalTabstop: p.isFinalTabstop,
                snippet: this
            };
            Object.defineProperty(res, 'snippet', {
                enumerable: false
            });
            if (p.choice) {
                let { options } = p.choice;
                if (options && options.length) {
                    res.choice = options.map(o => o.value);
                }
            }
            return res;
        });
    }
}
exports.CocSnippet = CocSnippet;
//# sourceMappingURL=snippet.js.map