"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const logger = require('../util/logger')('willSaveHandler');
class WillSaveUntilHandler {
    constructor(workspace) {
        this.workspace = workspace;
        this.callbacks = [];
    }
    get nvim() {
        return this.workspace.nvim;
    }
    addCallback(callback, thisArg, clientId) {
        let fn = (event) => {
            let { nvim, workspace } = this;
            let ev = Object.assign({}, event);
            return new Promise(resolve => {
                let called = false;
                ev.waitUntil = (thenable) => {
                    called = true;
                    let { document } = ev;
                    let timer = setTimeout(() => {
                        workspace.showMessage(`${clientId} will save operation timeout after 0.5s`, 'warning');
                        resolve(null);
                    }, 500);
                    Promise.resolve(thenable).then((edits) => {
                        clearTimeout(timer);
                        let doc = workspace.getDocument(document.uri);
                        if (doc && edits && vscode_languageserver_protocol_1.TextEdit.is(edits[0])) {
                            doc.applyEdits(nvim, edits).then(() => {
                                // make sure server received ChangedText
                                setTimeout(resolve, 50);
                            }, e => {
                                logger.error(e);
                                workspace.showMessage(`${clientId} error on applyEdits ${e.message}`, 'error');
                                resolve();
                            });
                        }
                        else {
                            resolve();
                        }
                    }, e => {
                        clearTimeout(timer);
                        workspace.showMessage(`${clientId} error on willSaveUntil ${e.message}`, 'error');
                        resolve();
                    });
                };
                callback.call(thisArg, ev);
                if (!called) {
                    resolve();
                }
            });
        };
        this.callbacks.push(fn);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            let idx = this.callbacks.indexOf(fn);
            if (idx != -1) {
                this.callbacks.splice(idx, 1);
            }
        });
    }
    get hasCallback() {
        let { callbacks } = this;
        return callbacks.length > 0;
    }
    async handeWillSaveUntil(event) {
        let { callbacks, workspace } = this;
        let { document } = event;
        if (!callbacks.length)
            return;
        for (let fn of callbacks) {
            let doc = workspace.getDocument(document.uri);
            event.document = doc.textDocument;
            try {
                await fn(event);
            }
            catch (e) {
                logger.error(e);
            }
        }
    }
}
exports.default = WillSaveUntilHandler;
//# sourceMappingURL=willSaveHandler.js.map