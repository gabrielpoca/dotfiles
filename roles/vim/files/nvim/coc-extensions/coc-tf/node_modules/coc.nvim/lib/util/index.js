"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const neovim_1 = require("@chemzqm/neovim");
const path_1 = __importDefault(require("path"));
const child_process_1 = __importStar(require("child_process"));
const debounce_1 = __importDefault(require("debounce"));
const fs_1 = __importDefault(require("fs"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const which_1 = __importDefault(require("which"));
const platform = __importStar(require("./platform"));
exports.platform = platform;
const isuri_1 = __importDefault(require("isuri"));
const logger = require('./logger')('util-index');
const prefix = '[coc.nvim] ';
var FileSchemes;
(function (FileSchemes) {
    FileSchemes["File"] = "file";
    FileSchemes["Untitled"] = "untitled";
})(FileSchemes = exports.FileSchemes || (exports.FileSchemes = {}));
function isSupportedScheme(scheme) {
    return ([FileSchemes.File, FileSchemes.Untitled].indexOf(scheme) >= 0);
}
exports.isSupportedScheme = isSupportedScheme;
function escapeSingleQuote(str) {
    return str.replace(/'/g, "''");
}
exports.escapeSingleQuote = escapeSingleQuote;
function echoErr(nvim, msg) {
    echoMsg(nvim, prefix + msg, 'Error'); // tslint:disable-line
}
exports.echoErr = echoErr;
function echoWarning(nvim, msg) {
    echoMsg(nvim, prefix + msg, 'WarningMsg'); // tslint:disable-line
}
exports.echoWarning = echoWarning;
function echoMessage(nvim, msg) {
    echoMsg(nvim, prefix + msg, 'MoreMsg'); // tslint:disable-line
}
exports.echoMessage = echoMessage;
function wait(ms) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
}
exports.wait = wait;
function echoMsg(nvim, msg, hl) {
    nvim.callTimer('coc#util#echo_messages', [hl, msg.split('\n')], true);
}
function getUri(fullpath, id, buftype) {
    if (buftype != '')
        return `${buftype}:${id}`;
    if (!fullpath)
        return `untitled:${id}`;
    if (path_1.default.isAbsolute(fullpath))
        return vscode_uri_1.default.file(fullpath).toString();
    if (isuri_1.default.isValid(fullpath))
        return vscode_uri_1.default.parse(fullpath).toString();
    return `unknown:${id}`;
}
exports.getUri = getUri;
function disposeAll(disposables) {
    while (disposables.length) {
        const item = disposables.pop();
        if (item) {
            item.dispose();
        }
    }
}
exports.disposeAll = disposeAll;
function executable(command) {
    try {
        which_1.default.sync(command);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.executable = executable;
function createNvim() {
    let p = which_1.default.sync('nvim');
    let proc = child_process_1.default.spawn(p, ['-u', 'NORC', '-i', 'NONE', '--embed', '--headless'], {
        shell: false
    });
    return neovim_1.attach({ proc });
}
exports.createNvim = createNvim;
function runCommand(cmd, opts = {}, timeout) {
    return new Promise((resolve, reject) => {
        let timer;
        if (timeout) {
            timer = setTimeout(() => {
                reject(new Error(`timeout after ${timeout}s`));
            }, timeout * 1000);
        }
        child_process_1.exec(cmd, opts, (err, stdout) => {
            if (timer)
                clearTimeout(timer);
            if (err) {
                reject(new Error(`exited with ${err.code}`));
                return;
            }
            resolve(stdout);
        });
    });
}
exports.runCommand = runCommand;
function watchFile(filepath, onChange) {
    let callback = debounce_1.default(onChange, 100);
    let watcher = fs_1.default.watch(filepath, {
        persistent: true,
        recursive: false,
        encoding: 'utf8'
    }, () => {
        callback();
    });
    return vscode_languageserver_protocol_1.Disposable.create(() => {
        watcher.close();
    });
}
exports.watchFile = watchFile;
function isRunning(pid) {
    try {
        let res = process.kill(pid, 0);
        return res == true;
    }
    catch (e) {
        return e.code === 'EPERM';
    }
}
exports.isRunning = isRunning;
function getKeymapModifier(mode) {
    if (mode == 'n' || mode == 'v')
        return '';
    if (mode == 'i')
        return '<C-o>';
    if (mode == 's' || mode == 'x')
        return '<Esc>';
    return '';
}
exports.getKeymapModifier = getKeymapModifier;
//# sourceMappingURL=index.js.map